<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-Hans" xml:lang="zh-Hans"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>6 因果推断框架 – 计量模型及应用</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/7工具变量法.html" rel="next">
<link href="../chapters/5离散与受限因变量模型.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-70a47bd5681a7291082a5b9f83d58762.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "没有结果",
    "search-matching-documents-text": "匹配的文档",
    "search-copy-link-title": "复制搜索链接",
    "search-hide-matches-text": "隐藏其它匹配结果",
    "search-more-match-text": "更多匹配结果",
    "search-more-matches-text": "更多匹配结果",
    "search-clear-button-title": "清除",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "提交",
    "search-label": "搜索"
  }
}</script>
<meta name="mermaid-theme" content="forest">
<script src="../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="science-textbook.css">
</head>

<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="展开或折叠侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/6因果推断框架.html">II 因果推断方法</a></li><li class="breadcrumb-item"><a href="../chapters/6因果推断框架.html"><span class="chapter-title">6 因果推断框架</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="展开或折叠侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="搜索" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">计量模型及应用</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="搜索"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">简介</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">说明</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">I 数据与模型</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="展开或折叠此栏">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/1线性回归.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">1 线性回归基础</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/2横截面数据分析.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">2 横截面数据：假设违反的诊断与修正</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/3面板数据模型.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">3 面板数据模型</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/4时间序列分析.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">4 时间序列分析</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/5离散与受限因变量模型.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">5 离散数据与受限因变量模型</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">II 因果推断方法</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="展开或折叠此栏">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/6因果推断框架.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">6 因果推断框架</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/7工具变量法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">7 工具变量法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/8倾向得分匹配.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">8 倾向得分匹配</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/9双重差分法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">9 双重差分法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/10断点回归.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">10 断点回归</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/11合成控制法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">11 合成控制法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/12回归控制法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">12 回归控制法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/13中介效应与调节效应.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">13 中介效应与调节效应</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">III 理论与算法</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="展开或折叠此栏">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/14大样本理论.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">14 大样本理论</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/15最大似然估计法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">15 最大似然估计理论</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/16广义矩估计法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">16 广义矩估计法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/17蒙特卡洛法与自助法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">17 蒙特卡洛法与自助法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/18优化算法与数值方法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">18 数值优化与矩阵方法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/19机器学习在计量中的应用.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">19 机器学习在计量中的应用</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">目录</h2>
   
  <ul>
  <li><a href="#本章导读" id="toc-本章导读" class="nav-link active" data-scroll-target="#本章导读">本章导读</a></li>
  <li><a href="#从相关到因果问题的根本转变" id="toc-从相关到因果问题的根本转变" class="nav-link" data-scroll-target="#从相关到因果问题的根本转变">6.1 从相关到因果：问题的根本转变</a>
  <ul class="collapse">
  <li><a href="#相关性分析的局限" id="toc-相关性分析的局限" class="nav-link" data-scroll-target="#相关性分析的局限">6.1.1 相关性分析的局限</a></li>
  <li><a href="#经济研究中的因果问题类型" id="toc-经济研究中的因果问题类型" class="nav-link" data-scroll-target="#经济研究中的因果问题类型">6.1.2 经济研究中的因果问题类型</a></li>
  </ul></li>
  <li><a href="#潜在结果框架因果推断的统一语言" id="toc-潜在结果框架因果推断的统一语言" class="nav-link" data-scroll-target="#潜在结果框架因果推断的统一语言">6.2 潜在结果框架：因果推断的统一语言</a>
  <ul class="collapse">
  <li><a href="#基本设定与符号体系" id="toc-基本设定与符号体系" class="nav-link" data-scroll-target="#基本设定与符号体系">6.2.1 基本设定与符号体系</a></li>
  <li><a href="#因果推断的根本问题" id="toc-因果推断的根本问题" class="nav-link" data-scroll-target="#因果推断的根本问题">6.2.2 因果推断的”根本问题”</a></li>
  <li><a href="#主要因果参数" id="toc-主要因果参数" class="nav-link" data-scroll-target="#主要因果参数">6.2.3 主要因果参数</a></li>
  </ul></li>
  <li><a href="#稳定性假设与选择偏差" id="toc-稳定性假设与选择偏差" class="nav-link" data-scroll-target="#稳定性假设与选择偏差">6.3 稳定性假设与选择偏差</a>
  <ul class="collapse">
  <li><a href="#sutva假设及其经济含义" id="toc-sutva假设及其经济含义" class="nav-link" data-scroll-target="#sutva假设及其经济含义">6.3.1 SUTVA假设及其经济含义</a></li>
  <li><a href="#选择偏差因果推断的核心障碍" id="toc-选择偏差因果推断的核心障碍" class="nav-link" data-scroll-target="#选择偏差因果推断的核心障碍">6.3.2 选择偏差：因果推断的核心障碍</a></li>
  <li><a href="#选择偏差的类型与来源" id="toc-选择偏差的类型与来源" class="nav-link" data-scroll-target="#选择偏差的类型与来源">6.3.3 选择偏差的类型与来源</a></li>
  </ul></li>
  <li><a href="#随机化实验选择偏差的黄金标准解" id="toc-随机化实验选择偏差的黄金标准解" class="nav-link" data-scroll-target="#随机化实验选择偏差的黄金标准解">6.4 随机化实验：选择偏差的”黄金标准解”</a>
  <ul class="collapse">
  <li><a href="#随机化的理论保障" id="toc-随机化的理论保障" class="nav-link" data-scroll-target="#随机化的理论保障">6.4.1 随机化的理论保障</a></li>
  <li><a href="#经济学实验的设计类型" id="toc-经济学实验的设计类型" class="nav-link" data-scroll-target="#经济学实验的设计类型">6.4.2 经济学实验的设计类型</a></li>
  <li><a href="#随机化实验的局限与挑战" id="toc-随机化实验的局限与挑战" class="nav-link" data-scroll-target="#随机化实验的局限与挑战">6.4.3 随机化实验的局限与挑战</a></li>
  </ul></li>
  <li><a href="#非混杂性观测研究的识别基石" id="toc-非混杂性观测研究的识别基石" class="nav-link" data-scroll-target="#非混杂性观测研究的识别基石">6.5 非混杂性：观测研究的识别基石</a>
  <ul class="collapse">
  <li><a href="#条件独立性的形式化表达" id="toc-条件独立性的形式化表达" class="nav-link" data-scroll-target="#条件独立性的形式化表达">6.5.1 条件独立性的形式化表达</a></li>
  <li><a href="#非混杂性的经济学解释" id="toc-非混杂性的经济学解释" class="nav-link" data-scroll-target="#非混杂性的经济学解释">6.5.2 非混杂性的经济学解释</a></li>
  <li><a href="#假设的实践评估" id="toc-假设的实践评估" class="nav-link" data-scroll-target="#假设的实践评估">6.5.3 假设的实践评估</a></li>
  </ul></li>
  <li><a href="#内生性计量经济学的经典难题" id="toc-内生性计量经济学的经典难题" class="nav-link" data-scroll-target="#内生性计量经济学的经典难题">6.6 内生性：计量经济学的经典难题</a>
  <ul class="collapse">
  <li><a href="#内生性的三个来源" id="toc-内生性的三个来源" class="nav-link" data-scroll-target="#内生性的三个来源">6.6.1 内生性的三个来源</a></li>
  <li><a href="#内生性的统计后果" id="toc-内生性的统计后果" class="nav-link" data-scroll-target="#内生性的统计后果">6.6.2 内生性的统计后果</a></li>
  <li><a href="#内生性与非混杂性的关系" id="toc-内生性与非混杂性的关系" class="nav-link" data-scroll-target="#内生性与非混杂性的关系">6.6.3 内生性与非混杂性的关系</a></li>
  </ul></li>
  <li><a href="#线性回归的因果解释条件" id="toc-线性回归的因果解释条件" class="nav-link" data-scroll-target="#线性回归的因果解释条件">6.7 线性回归的因果解释条件</a>
  <ul class="collapse">
  <li><a href="#随机化实验下的线性回归" id="toc-随机化实验下的线性回归" class="nav-link" data-scroll-target="#随机化实验下的线性回归">6.7.1 随机化实验下的线性回归</a></li>
  <li><a href="#满足非混杂性条件的线性回归" id="toc-满足非混杂性条件的线性回归" class="nav-link" data-scroll-target="#满足非混杂性条件的线性回归">6.7.2 满足非混杂性条件的线性回归</a></li>
  <li><a href="#回归控制法扩展与应用" id="toc-回归控制法扩展与应用" class="nav-link" data-scroll-target="#回归控制法扩展与应用">6.7.3 回归控制法：扩展与应用</a></li>
  <li><a href="#遗漏变量偏差的定量分析" id="toc-遗漏变量偏差的定量分析" class="nav-link" data-scroll-target="#遗漏变量偏差的定量分析">6.7.4 遗漏变量偏差的定量分析</a></li>
  </ul></li>
  <li><a href="#因果推断方法分类框架" id="toc-因果推断方法分类框架" class="nav-link" data-scroll-target="#因果推断方法分类框架">6.8 因果推断方法分类框架</a>
  <ul class="collapse">
  <li><a href="#基于识别策略的分类体系" id="toc-基于识别策略的分类体系" class="nav-link" data-scroll-target="#基于识别策略的分类体系">6.8.1 基于识别策略的分类体系</a></li>
  <li><a href="#各类方法的比较分析" id="toc-各类方法的比较分析" class="nav-link" data-scroll-target="#各类方法的比较分析">6.8.2 各类方法的比较分析</a></li>
  <li><a href="#固定效应模型处理时不变混杂" id="toc-固定效应模型处理时不变混杂" class="nav-link" data-scroll-target="#固定效应模型处理时不变混杂">6.8.3 固定效应模型：处理时不变混杂</a></li>
  </ul></li>
  <li><a href="#实证案例分析最低工资的就业效应" id="toc-实证案例分析最低工资的就业效应" class="nav-link" data-scroll-target="#实证案例分析最低工资的就业效应">6.9 实证案例分析：最低工资的就业效应</a>
  <ul class="collapse">
  <li><a href="#研究背景与经典争议" id="toc-研究背景与经典争议" class="nav-link" data-scroll-target="#研究背景与经典争议">6.9.1 研究背景与经典争议</a></li>
  <li><a href="#card和krueger1994的自然实验" id="toc-card和krueger1994的自然实验" class="nav-link" data-scroll-target="#card和krueger1994的自然实验">6.9.2 Card和Krueger（1994）的自然实验</a></li>
  <li><a href="#研究设计与识别策略" id="toc-研究设计与识别策略" class="nav-link" data-scroll-target="#研究设计与识别策略">6.9.3 研究设计与识别策略</a></li>
  <li><a href="#stata操作演示目录" id="toc-stata操作演示目录" class="nav-link" data-scroll-target="#stata操作演示目录">6.9.4 Stata操作演示（目录）</a></li>
  <li><a href="#r操作演示目录" id="toc-r操作演示目录" class="nav-link" data-scroll-target="#r操作演示目录">6.9.5 R操作演示（目录）</a></li>
  </ul></li>
  <li><a href="#本章总结" id="toc-本章总结" class="nav-link" data-scroll-target="#本章总结">本章总结</a>
  <ul class="collapse">
  <li><a href="#核心概念体系回顾" id="toc-核心概念体系回顾" class="nav-link" data-scroll-target="#核心概念体系回顾">核心概念体系回顾</a></li>
  <li><a href="#方法体系梳理" id="toc-方法体系梳理" class="nav-link" data-scroll-target="#方法体系梳理">方法体系梳理</a></li>
  <li><a href="#关键理论关系" id="toc-关键理论关系" class="nav-link" data-scroll-target="#关键理论关系">关键理论关系</a></li>
  <li><a href="#从理论到实践的桥梁" id="toc-从理论到实践的桥梁" class="nav-link" data-scroll-target="#从理论到实践的桥梁">从理论到实践的桥梁</a></li>
  <li><a href="#实践指导原则" id="toc-实践指导原则" class="nav-link" data-scroll-target="#实践指导原则">实践指导原则</a></li>
  <li><a href="#扩展思考" id="toc-扩展思考" class="nav-link" data-scroll-target="#扩展思考">扩展思考</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/6因果推断框架.html">II 因果推断方法</a></li><li class="breadcrumb-item"><a href="../chapters/6因果推断框架.html"><span class="chapter-title">6 因果推断框架</span></a></li></ol></nav>
<div class="quarto-title">
<h1 class="title"><span class="chapter-title">6 因果推断框架</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="本章导读" class="level2">
<h2 class="anchored" data-anchor-id="本章导读">本章导读</h2>
<blockquote class="blockquote">
<p><strong>“相关性不是因果性”</strong>——这一原则构成了现代计量经济学的基石。在前几章中，我们学习了如何使用回归模型描述变量间的相关关系。从本章开始，我们将回答一个更根本的问题：<strong>如何从观测数据中识别因果关系？</strong> 本章将建立因果推断的基本理论框架，为后续章节的具体方法奠定基础。</p>
</blockquote>
<p>在经济学研究中，我们经常关心诸如”教育对收入的影响”、“最低工资对就业的影响”、“货币政策对经济增长的影响”等问题。这些问题的本质都是<strong>因果问题</strong>——我们想知道如果改变某个变量（处理变量），结果变量会发生怎样的变化。然而，从观测数据中识别因果关系面临着<strong>选择偏差</strong>、<strong>内生性</strong>等根本挑战。本章将系统介绍因果推断的理论框架，为理解后续章节的具体方法提供坚实基础。</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    A[随机对照实验 RCT&lt;br/&gt;金标准] --&gt; B{现实约束：无法实验}
    B --&gt; C[第一代：OLS/回归控制&lt;br/&gt;假设：条件独立性]
    C --&gt; D{假设违背：未观测混杂}
    
    D --&gt; E[第二代：自然实验方法]
    E --&gt; F[工具变量法 IV&lt;br/&gt;假设：排他性约束]
    E --&gt; G[断点回归 RD&lt;br/&gt;假设：连续性]
    E --&gt; H[双重差分法 DID&lt;br/&gt;假设：平行趋势]
    
    D --&gt; I[第三代：构造对照组]
    I --&gt; J[倾向得分匹配 PSM&lt;br/&gt;假设：强可忽略性]
    I --&gt; K[合成控制法&lt;br/&gt;假设：可合成性]
    
    D --&gt; L[第四代：面板数据方法]
    L --&gt; M[固定效应模型 FE&lt;br/&gt;假设：时不变混杂]
    
    F &amp; G &amp; H &amp; J &amp; K &amp; M --&gt; N[方法融合与稳健性检验]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="从相关到因果问题的根本转变" class="level2">
<h2 class="anchored" data-anchor-id="从相关到因果问题的根本转变">6.1 从相关到因果：问题的根本转变</h2>
<section id="相关性分析的局限" class="level3">
<h3 class="anchored" data-anchor-id="相关性分析的局限">6.1.1 相关性分析的局限</h3>
<p>考虑以下三个经典例子：</p>
<ol type="1">
<li><strong>冰淇淋销量与溺水人数</strong>：两者呈现正相关，但这是因果关系吗？实际上，两者都受到季节（夏季）的影响。</li>
<li><strong>教育年限与收入</strong>：受教育程度高的人通常收入更高，但这是因为教育本身提高了生产率，还是因为能力高的人既倾向于接受更多教育又容易获得高收入？</li>
<li><strong>班级规模与学生成绩</strong>：小班教学的学生成绩更好，但这是因为班级规模的影响，还是因为资源丰富的学校既倾向于小班化又提供更好的教学条件？</li>
</ol>
<p>这些例子揭示了相关性与因果性的根本区别。<strong>相关性</strong>描述的是变量间的统计关联，而<strong>因果性</strong>描述的是一个变量的变化如何导致另一个变量的变化。</p>
</section>
<section id="经济研究中的因果问题类型" class="level3">
<h3 class="anchored" data-anchor-id="经济研究中的因果问题类型">6.1.2 经济研究中的因果问题类型</h3>
<p>经济学中的因果问题主要分为三类：</p>
<ol type="1">
<li><strong>政策干预效果评估</strong>：评估某项政策（如税收改革、教育补贴）对经济结果的影响。</li>
<li><strong>行为反应机制分析</strong>：分析个体或企业对激励变化的反应。</li>
<li><strong>市场均衡效应识别</strong>：识别市场结构变化对均衡价格和数量的影响。</li>
</ol>
</section>
</section>
<section id="潜在结果框架因果推断的统一语言" class="level2">
<h2 class="anchored" data-anchor-id="潜在结果框架因果推断的统一语言">6.2 潜在结果框架：因果推断的统一语言</h2>
<section id="基本设定与符号体系" class="level3">
<h3 class="anchored" data-anchor-id="基本设定与符号体系">6.2.1 基本设定与符号体系</h3>
<p>潜在结果框架（Potential Outcomes Framework），又称Rubin因果模型，由Donald Rubin等人发展，已成为现代因果推断的标准语言。</p>
<p>对于每个个体<span class="math inline">\(i\)</span>，我们定义：</p>
<ul>
<li><strong>处理状态</strong>：<span class="math inline">\(T_i \in \{0, 1\}\)</span>，其中<span class="math inline">\(T_i = 1\)</span>表示接受处理（如参加培训项目），<span class="math inline">\(T_i = 0\)</span>表示未接受处理（控制组）</li>
<li><strong>潜在结果</strong>：<span class="math inline">\(Y_i(1)\)</span>表示如果个体<span class="math inline">\(i\)</span>接受处理时的结果，<span class="math inline">\(Y_i(0)\)</span>表示如果个体<span class="math inline">\(i\)</span>未接受处理时的结果</li>
</ul>
<p>观测到的结果可以表示为： <span class="math display">\[
Y_i^{\text{obs}} = T_i Y_i(1) + (1 - T_i) Y_i(0)
\]</span></p>
</section>
<section id="因果推断的根本问题" class="level3">
<h3 class="anchored" data-anchor-id="因果推断的根本问题">6.2.2 因果推断的”根本问题”</h3>
<p>因果推断面临的根本问题是：<strong>对于同一个体，我们只能观测到一种潜在结果</strong>。如果个体接受了处理（<span class="math inline">\(T_i = 1\)</span>），我们观测到<span class="math inline">\(Y_i(1)\)</span>但无法观测<span class="math inline">\(Y_i(0)\)</span>；如果个体未接受处理（<span class="math inline">\(T_i = 0\)</span>），我们观测到<span class="math inline">\(Y_i(0)\)</span>但无法观测<span class="math inline">\(Y_i(1)\)</span>。这个反事实结果（Counterfactual Outcome）的不可观测性被称为<strong>因果推断的根本问题</strong>。</p>
</section>
<section id="主要因果参数" class="level3">
<h3 class="anchored" data-anchor-id="主要因果参数">6.2.3 主要因果参数</h3>
<p>由于个体处理效应<span class="math inline">\(\tau_i = Y_i(1) - Y_i(0)\)</span>不可观测，我们转向估计群体层面的平均效应：</p>
<ol type="1">
<li><p><strong>平均处理效应</strong>（Average Treatment Effect, ATE）： <span class="math display">\[
\tau_{\text{ATE}} = \mathbb{E}[Y_i(1) - Y_i(0)]
\]</span></p></li>
<li><p><strong>处理组的平均处理效应</strong>（Average Treatment Effect on the Treated, ATT）： <span class="math display">\[
\tau_{\text{ATT}} = \mathbb{E}[Y_i(1) - Y_i(0) | T_i = 1]
\]</span></p></li>
<li><p><strong>控制组的平均处理效应</strong>（Average Treatment Effect on the Controls, ATC）： <span class="math display">\[
\tau_{\text{ATC}} = \mathbb{E}[Y_i(1) - Y_i(0) | T_i = 0]
\]</span></p></li>
</ol>
</section>
</section>
<section id="稳定性假设与选择偏差" class="level2">
<h2 class="anchored" data-anchor-id="稳定性假设与选择偏差">6.3 稳定性假设与选择偏差</h2>
<section id="sutva假设及其经济含义" class="level3">
<h3 class="anchored" data-anchor-id="sutva假设及其经济含义">6.3.1 SUTVA假设及其经济含义</h3>
<p>稳定单位处理值假设（Stable Unit Treatment Value Assumption, SUTVA）包含两个部分：</p>
<ol type="1">
<li><p><strong>无干扰性</strong>：个体<span class="math inline">\(i\)</span>的结果不受其他个体处理状态的影响。 <span class="math display">\[
Y_i(T_1, T_2, ..., T_n) = Y_i(T_i)
\]</span></p></li>
<li><p><strong>处理一致性</strong>：同一处理对所有个体具有相同的含义和效果。</p></li>
</ol>
<p>在经济学中，SUTVA的违背常见于： - <strong>溢出效应</strong>：一个地区的基础设施投资可能影响邻近地区 - <strong>一般均衡效应</strong>：大规模政策可能改变市场价格和资源配置 - <strong>网络效应</strong>：个体的行为可能受到社会网络的影响</p>
</section>
<section id="选择偏差因果推断的核心障碍" class="level3">
<h3 class="anchored" data-anchor-id="选择偏差因果推断的核心障碍">6.3.2 选择偏差：因果推断的核心障碍</h3>
<p>选择偏差源于处理组和对照组在潜在结果上的系统性差异。观测到的均值差异可以分解为： <span class="math display">\[
\mathbb{E}[Y_i^{\text{obs}} | T_i = 1] - \mathbb{E}[Y_i^{\text{obs}} | T_i = 0] = \tau_{\text{ATT}} + \text{选择偏差}
\]</span></p>
<p>其中选择偏差为： <span class="math display">\[
\text{选择偏差} = \mathbb{E}[Y_i(0) | T_i = 1] - \mathbb{E}[Y_i(0) | T_i = 0]
\]</span></p>
<p>当处理组个体即使不接受处理，其潜在结果<span class="math inline">\(Y_i(0)\)</span>也不同于对照组时，就产生了选择偏差。</p>
</section>
<section id="选择偏差的类型与来源" class="level3">
<h3 class="anchored" data-anchor-id="选择偏差的类型与来源">6.3.3 选择偏差的类型与来源</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 37%">
<col style="width: 25%">
<col style="width: 37%">
</colgroup>
<thead>
<tr class="header">
<th>偏差类型</th>
<th>来源</th>
<th>经济实例</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>可观测特征偏差</strong></td>
<td>处理组和对照组在可观测特征上的差异</td>
<td>高收入者更可能参加培训项目</td>
</tr>
<tr class="even">
<td><strong>不可观测特征偏差</strong></td>
<td>处理组和对照组在不可观测特征上的差异</td>
<td>能力高的人既倾向于接受教育又容易获得高收入</td>
</tr>
<tr class="odd">
<td><strong>自选择偏差</strong></td>
<td>个体基于预期结果选择是否接受处理</td>
<td>预期培训效果好的个体更可能参加培训</td>
</tr>
<tr class="even">
<td><strong>制度性选择偏差</strong></td>
<td>制度规则导致的选择</td>
<td>贫困线以下的家庭自动获得福利</td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="随机化实验选择偏差的黄金标准解" class="level2">
<h2 class="anchored" data-anchor-id="随机化实验选择偏差的黄金标准解">6.4 随机化实验：选择偏差的”黄金标准解”</h2>
<section id="随机化的理论保障" class="level3">
<h3 class="anchored" data-anchor-id="随机化的理论保障">6.4.1 随机化的理论保障</h3>
<p>随机化实验通过随机分配处理状态，确保处理组和对照组在<strong>所有特征</strong>（包括可观测和不可观测特征）上具有可比性： <span class="math display">\[
T_i \perp \{Y_i(1), Y_i(0), X_i, U_i\}
\]</span></p>
<p>其中<span class="math inline">\(X_i\)</span>表示可观测特征，<span class="math inline">\(U_i\)</span>表示不可观测特征。这一独立性意味着： <span class="math display">\[
\mathbb{E}[Y_i(0) | T_i = 1] = \mathbb{E}[Y_i(0) | T_i = 0]
\]</span></p>
<p>因此，选择偏差为零，ATE的简单均值差估计量是一致的： <span class="math display">\[
\hat{\tau}_{\text{ATE}} = \frac{1}{n_1} \sum_{i: T_i = 1} Y_i - \frac{1}{n_0} \sum_{i: T_i = 0} Y_i
\]</span></p>
</section>
<section id="经济学实验的设计类型" class="level3">
<h3 class="anchored" data-anchor-id="经济学实验的设计类型">6.4.2 经济学实验的设计类型</h3>
<ol type="1">
<li><strong>实验室实验</strong>：在控制环境下进行，适用于检验理论机制。</li>
<li><strong>田野实验</strong>：在自然环境中进行，具有更高的外部有效性。</li>
<li><strong>自然实验</strong>：利用外生政策变化或自然事件作为处理分配。</li>
</ol>
</section>
<section id="随机化实验的局限与挑战" class="level3">
<h3 class="anchored" data-anchor-id="随机化实验的局限与挑战">6.4.3 随机化实验的局限与挑战</h3>
<ol type="1">
<li><strong>外部有效性</strong>：实验环境可能无法反映真实世界</li>
<li><strong>伦理约束</strong>：某些处理（如有害物质）不能随机分配</li>
<li><strong>成本高昂</strong>：大规模实验需要大量资源</li>
<li><strong>依从性问题</strong>：实验对象可能不遵守分配</li>
<li><strong>处理效应异质性</strong>：简单均值差可能掩盖效应异质性</li>
</ol>
</section>
</section>
<section id="非混杂性观测研究的识别基石" class="level2">
<h2 class="anchored" data-anchor-id="非混杂性观测研究的识别基石">6.5 非混杂性：观测研究的识别基石</h2>
<section id="条件独立性的形式化表达" class="level3">
<h3 class="anchored" data-anchor-id="条件独立性的形式化表达">6.5.1 条件独立性的形式化表达</h3>
<p>当随机化不可行时，我们需要依赖观测数据。<strong>强可忽略性假设</strong>（Strong Ignorability）是观测研究中因果识别的基础： <span class="math display">\[
(Y_i(1), Y_i(0)) \perp T_i | X_i
\]</span></p>
<p>这一假设要求：在给定协变量<span class="math inline">\(X_i\)</span>的条件下，处理分配<span class="math inline">\(T_i\)</span>与潜在结果独立。此外，还需要<strong>共同支持条件</strong>： <span class="math display">\[
0 &lt; \Pr(T_i = 1 | X_i = x) &lt; 1 \quad \text{对于所有} \ x
\]</span></p>
</section>
<section id="非混杂性的经济学解释" class="level3">
<h3 class="anchored" data-anchor-id="非混杂性的经济学解释">6.5.2 非混杂性的经济学解释</h3>
<p>非混杂性假设意味着：所有同时影响处理选择和结果的变量都已包含在<span class="math inline">\(X_i\)</span>中。在给定<span class="math inline">\(X_i\)</span>的层内，处理分配如同随机。</p>
<p>考虑教育对收入的影响例子： - 如果能力既影响教育选择又影响收入，且能力可观测，则控制能力后，非混杂性可能成立。 - 如果能力不可观测，则非混杂性被违背，估计将有偏。</p>
</section>
<section id="假设的实践评估" class="level3">
<h3 class="anchored" data-anchor-id="假设的实践评估">6.5.3 假设的实践评估</h3>
<p>在实践中，我们需要：</p>
<ol type="1">
<li><strong>基于经济理论</strong>选择控制变量</li>
<li><strong>检验平衡性</strong>：处理组和对照组在<span class="math inline">\(X_i\)</span>上是否平衡</li>
<li><strong>进行敏感性分析</strong>：评估结论对未观测混杂的稳健性</li>
</ol>
</section>
</section>
<section id="内生性计量经济学的经典难题" class="level2">
<h2 class="anchored" data-anchor-id="内生性计量经济学的经典难题">6.6 内生性：计量经济学的经典难题</h2>
<section id="内生性的三个来源" class="level3">
<h3 class="anchored" data-anchor-id="内生性的三个来源">6.6.1 内生性的三个来源</h3>
<p>内生性指解释变量与误差项相关，是因果推断的主要障碍：</p>
<ol type="1">
<li><strong>遗漏变量</strong>：未观测的混杂变量<span class="math inline">\(U_i\)</span>既影响<span class="math inline">\(T_i\)</span>又影响<span class="math inline">\(Y_i\)</span></li>
<li><strong>反向因果</strong>：<span class="math inline">\(Y_i\)</span>影响<span class="math inline">\(T_i\)</span>，同时<span class="math inline">\(T_i\)</span>影响<span class="math inline">\(Y_i\)</span></li>
<li><strong>测量误差</strong>：<span class="math inline">\(T_i\)</span>的测量存在误差</li>
</ol>
</section>
<section id="内生性的统计后果" class="level3">
<h3 class="anchored" data-anchor-id="内生性的统计后果">6.6.2 内生性的统计后果</h3>
<p>考虑线性模型： <span class="math display">\[
Y_i = \alpha + \beta T_i + \gamma' X_i + \epsilon_i
\]</span></p>
<p>如果<span class="math inline">\(\mathbb{E}[\epsilon_i | T_i, X_i] \neq 0\)</span>，则：</p>
<ol type="1">
<li>OLS估计量<span class="math inline">\(\hat{\beta}\)</span>有偏且不一致</li>
<li>标准误差估计有偏</li>
<li>假设检验失效</li>
<li>预测和政策建议不可靠</li>
</ol>
</section>
<section id="内生性与非混杂性的关系" class="level3">
<h3 class="anchored" data-anchor-id="内生性与非混杂性的关系">6.6.3 内生性与非混杂性的关系</h3>
<p>内生性和非混杂性是同一问题的两种表述。非混杂性成立意味着无遗漏变量问题，从而消除了一种内生性来源。具体关系如下：</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    A[内生性存在] &lt;--&gt; B[非混杂性违背]
    C[遗漏变量] --&gt; A
    D[反向因果] --&gt; A
    E[测量误差] --&gt; A
    
    F[非混杂性成立] --&gt; G[内生性部分消除&lt;br/&gt;仅解决遗漏变量]
    H[条件独立性] --&gt; F
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
</section>
<section id="线性回归的因果解释条件" class="level2">
<h2 class="anchored" data-anchor-id="线性回归的因果解释条件">6.7 线性回归的因果解释条件</h2>
<section id="随机化实验下的线性回归" class="level3">
<h3 class="anchored" data-anchor-id="随机化实验下的线性回归">6.7.1 随机化实验下的线性回归</h3>
<p>在随机化实验中，即使是最简单的线性回归也能提供无偏的因果估计： <span class="math display">\[
Y_i = \alpha + \beta T_i + \epsilon_i
\]</span></p>
<p>随机化保证<span class="math inline">\(\mathbb{E}[\epsilon_i | T_i] = 0\)</span>，因此<span class="math inline">\(\hat{\beta} = \widehat{\text{ATE}}\)</span>。</p>
</section>
<section id="满足非混杂性条件的线性回归" class="level3">
<h3 class="anchored" data-anchor-id="满足非混杂性条件的线性回归">6.7.2 满足非混杂性条件的线性回归</h3>
<p>当非混杂性成立时，包含所有混杂变量的线性回归可以提供无偏估计： <span class="math display">\[
Y_i = \alpha + \beta T_i + \gamma' X_i + \epsilon_i
\]</span></p>
<p>条件独立性<span class="math inline">\((Y_i(1), Y_i(0)) \perp T_i | X_i\)</span>保证了<span class="math inline">\(\mathbb{E}[\epsilon_i | T_i, X_i] = 0\)</span>，因此<span class="math inline">\(\hat{\beta} = \widehat{\text{ATE}}\)</span>。</p>
</section>
<section id="回归控制法扩展与应用" class="level3">
<h3 class="anchored" data-anchor-id="回归控制法扩展与应用">6.7.3 回归控制法：扩展与应用</h3>
<p><strong>回归控制法</strong>（Regression Adjustment）是线性回归在因果推断中的直接应用。当非混杂性成立时，通过控制所有混杂变量<span class="math inline">\(X_i\)</span>，我们可以获得处理效应的无偏估计。</p>
<p>在实践中，我们需要：</p>
<ol type="1">
<li>正确设定函数形式（考虑非线性、交互项）</li>
<li>检查共同支持条件</li>
<li>进行模型诊断和稳健性检验</li>
</ol>
</section>
<section id="遗漏变量偏差的定量分析" class="level3">
<h3 class="anchored" data-anchor-id="遗漏变量偏差的定量分析">6.7.4 遗漏变量偏差的定量分析</h3>
<p>考虑真实数据生成过程为： <span class="math display">\[
Y_i = \alpha + \beta T_i + \gamma X_i + \delta U_i + \eta_i
\]</span></p>
<p>但如果我们只控制<span class="math inline">\(X_i\)</span>，估计模型为： <span class="math display">\[
Y_i = \tilde{\alpha} + \tilde{\beta} T_i + \tilde{\gamma} X_i + \tilde{\eta}_i
\]</span></p>
<p>那么<span class="math inline">\(\tilde{\beta}\)</span>的概率极限为： <span class="math display">\[
\text{plim} \ \tilde{\beta} = \beta + \delta \frac{\text{Cov}(T_i, U_i|X_i)}{\text{Var}(T_i|X_i)}
\]</span></p>
<p>偏差的大小取决于： 1. <span class="math inline">\(U_i\)</span>对<span class="math inline">\(Y_i\)</span>的影响强度（<span class="math inline">\(\delta\)</span>） 2. <span class="math inline">\(T_i\)</span>和<span class="math inline">\(U_i\)</span>在给定<span class="math inline">\(X_i\)</span>下的相关性</p>
</section>
</section>
<section id="因果推断方法分类框架" class="level2">
<h2 class="anchored" data-anchor-id="因果推断方法分类框架">6.8 因果推断方法分类框架</h2>
<section id="基于识别策略的分类体系" class="level3">
<h3 class="anchored" data-anchor-id="基于识别策略的分类体系">6.8.1 基于识别策略的分类体系</h3>
<p>现代因果推断方法可以根据其核心识别策略分为五大类：</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    A[因果推断方法] --&gt; B[实验方法]
    A --&gt; C[准实验方法]
    A --&gt; D[基于可忽略性方法]
    A --&gt; E[面板数据方法]
    A --&gt; F[合成控制方法]
    
    B --&gt; G[随机对照实验]
    
    C --&gt; H[工具变量法]
    C --&gt; I[断点回归]
    
    D --&gt; J[回归控制法]
    D --&gt; K[匹配方法]
    D --&gt; L[倾向得分加权]
    
    E --&gt; M[固定效应模型]
    E --&gt; N[双重差分法]
    E --&gt; O[事件研究法]
    
    F --&gt; P[经典合成控制]
    F --&gt; Q[广义合成控制]
    
    G &amp; H &amp; I &amp; J &amp; K &amp; L &amp; M &amp; N &amp; O &amp; P &amp; Q --&gt; R[因果效应估计]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="各类方法的比较分析" class="level3">
<h3 class="anchored" data-anchor-id="各类方法的比较分析">6.8.2 各类方法的比较分析</h3>
<table class="caption-top table">
<colgroup>
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
<col style="width: 16%">
</colgroup>
<thead>
<tr class="header">
<th>方法类别</th>
<th>代表方法</th>
<th>关键假设</th>
<th>估计参数</th>
<th>数据要求</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>实验方法</strong></td>
<td>随机对照实验</td>
<td>完美随机化</td>
<td>ATE</td>
<td>实验数据</td>
<td>可实施随机化</td>
</tr>
<tr class="even">
<td><strong>准实验方法</strong></td>
<td>工具变量法</td>
<td>外生工具变量</td>
<td>LATE</td>
<td>有效工具</td>
<td>有自然实验</td>
</tr>
<tr class="odd">
<td><strong>准实验方法</strong></td>
<td>断点回归</td>
<td>连续性假设</td>
<td>局部ATE</td>
<td>运行变量</td>
<td>有清晰断点</td>
</tr>
<tr class="even">
<td><strong>可忽略性方法</strong></td>
<td>回归控制法</td>
<td>条件独立性</td>
<td>ATE</td>
<td>丰富协变量</td>
<td>可测所有混杂</td>
</tr>
<tr class="odd">
<td><strong>可忽略性方法</strong></td>
<td>倾向得分匹配</td>
<td>强可忽略性</td>
<td>ATT</td>
<td>平衡协变量</td>
<td>对照组丰富</td>
</tr>
<tr class="even">
<td><strong>面板数据方法</strong></td>
<td>固定效应模型</td>
<td>时不变混杂</td>
<td>ATE</td>
<td>面板数据</td>
<td>个体异质性</td>
</tr>
<tr class="odd">
<td><strong>面板数据方法</strong></td>
<td>双重差分法</td>
<td>平行趋势</td>
<td>ATT</td>
<td>面板数据</td>
<td>政策评估</td>
</tr>
<tr class="even">
<td><strong>合成控制方法</strong></td>
<td>合成控制法</td>
<td>可合成性</td>
<td>ATT</td>
<td>时间序列</td>
<td>小样本政策评估</td>
</tr>
</tbody>
</table>
</section>
<section id="固定效应模型处理时不变混杂" class="level3">
<h3 class="anchored" data-anchor-id="固定效应模型处理时不变混杂">6.8.3 固定效应模型：处理时不变混杂</h3>
<section id="面板数据与因果识别的优势" class="level4">
<h4 class="anchored" data-anchor-id="面板数据与因果识别的优势">6.8.3.1 面板数据与因果识别的优势</h4>
<p>固定效应模型是处理观测数据中未观测混杂的重要方法，特别适用于<strong>面板数据</strong>（Panel Data）或<strong>追踪数据</strong>（Longitudinal Data）。面板数据的核心特征是每个个体（如个人、企业、地区）在多个时间点上被观测，这为我们处理因果推断问题提供了独特优势。</p>
<p><strong>面板数据结构</strong>： <span class="math display">\[
\{Y_{it}, T_{it}, X_{it}\}, \quad i = 1, ..., N; \quad t = 1, ..., T
\]</span> 其中： - <span class="math inline">\(i\)</span>：个体标识（如个人、企业、城市） - <span class="math inline">\(t\)</span>：时间标识（如年份、季度） - <span class="math inline">\(Y_{it}\)</span>：个体<span class="math inline">\(i\)</span>在时间<span class="math inline">\(t\)</span>的结果变量 - <span class="math inline">\(T_{it}\)</span>：个体<span class="math inline">\(i\)</span>在时间<span class="math inline">\(t\)</span>的处理状态（0或1） - <span class="math inline">\(X_{it}\)</span>：个体<span class="math inline">\(i\)</span>在时间<span class="math inline">\(t\)</span>的可观测协变量</p>
</section>
<section id="固定效应模型的因果识别机制" class="level4">
<h4 class="anchored" data-anchor-id="固定效应模型的因果识别机制">6.8.3.2 固定效应模型的因果识别机制</h4>
<p>考虑以下固定效应模型： <span class="math display">\[
Y_{it} = \alpha_i + \lambda_t + \beta T_{it} + \gamma' X_{it} + \epsilon_{it}
\]</span></p>
<p>其中： - <span class="math inline">\(\alpha_i\)</span>：<strong>个体固定效应</strong>，捕捉所有不随时间变化的个体特征 - <span class="math inline">\(\lambda_t\)</span>：<strong>时间固定效应</strong>，捕捉所有个体共同经历的时间趋势 - <span class="math inline">\(\beta\)</span>：处理效应，是我们关心的因果参数 - <span class="math inline">\(\epsilon_{it}\)</span>：时变冲击，满足<span class="math inline">\(\mathbb{E}[\epsilon_{it} | T_{it}, X_{it}, \alpha_i, \lambda_t] = 0\)</span></p>
<p>** 固定效应如何解决未观测混杂**</p>
<p>固定效应模型的威力在于<span class="math inline">\(\alpha_i\)</span>可以吸收<strong>所有不随时间变化的未观测混杂</strong>。考虑一个具体例子：</p>
<p><strong>研究问题</strong>：分析员工培训（<span class="math inline">\(T_{it}\)</span>）对工资（<span class="math inline">\(Y_{it}\)</span>）的因果效应。</p>
<p><strong>未观测混杂</strong>：员工的能力（<span class="math inline">\(U_i\)</span>）既影响是否参加培训，又影响工资水平。能力通常不可直接观测或难以准确测量。</p>
<p><strong>传统截面数据分析的问题</strong>： 如果使用截面数据，我们需要控制能力<span class="math inline">\(U_i\)</span>。但由于<span class="math inline">\(U_i\)</span>不可观测，导致遗漏变量偏差： <span class="math display">\[
\text{plim} \ \hat{\beta}_{OLS} = \beta + \frac{\text{Cov}(T_i, U_i)}{\text{Var}(T_i)}
\]</span></p>
<p><strong>固定效应模型的解决方案</strong>： 在面板数据中，我们可以将能力分解为： <span class="math display">\[
\text{能力}_i = \underbrace{\alpha_i}_{\text{时不变部分}} + \underbrace{v_{it}}_{\text{时变部分}}
\]</span></p>
<p>固定效应模型通过<span class="math inline">\(\alpha_i\)</span>吸收了时不变的能力部分。只要能力的大部分变异是时不变的，固定效应模型就能有效消除能力混杂带来的偏差。</p>
<p>固定效应模型的有效性依赖于以下关键假设：</p>
<ol type="1">
<li><p>严格外生性假设： <span class="math display">\[
\mathbb{E}[\epsilon_{it} | T_{i1}, ..., T_{iT}, X_{i1}, ..., X_{iT}, \alpha_i, \lambda_t] = 0
\]</span> 这意味着给定个体固定效应和时间固定效应后，处理变量<span class="math inline">\(T_{it}\)</span>和协变量<span class="math inline">\(X_{it}\)</span>与误差项<span class="math inline">\(\epsilon_{it}\)</span>不相关。</p></li>
<li><p>未观测混杂的时不变性： 所有未观测的混杂变量<span class="math inline">\(U_i\)</span>必须满足： <span class="math display">\[
U_i = \alpha_i + v_{it}, \quad \text{其中} \ \alpha_i \ \text{为时不变部分}
\]</span> 固定效应只能消除<span class="math inline">\(\alpha_i\)</span>部分，无法处理时变部分<span class="math inline">\(v_{it}\)</span>。</p></li>
<li><p>处理效应同质性（或已知的异质性模式）： <span class="math display">\[
Y_{it}(1) - Y_{it}(0) = \beta \quad \text{对所有} \ i,t
\]</span> 或至少处理效应的异质性模式是已知且可建模的。</p></li>
</ol>
</section>
<section id="估计方法与实现" class="level4">
<h4 class="anchored" data-anchor-id="估计方法与实现">6.8.3.3 估计方法与实现</h4>
<p>** 组内估计量（Within Estimator）**</p>
<p>固定效应模型最常用的估计方法是组内估计量，通过消除个体固定效应进行估计：</p>
<p>第一步：计算个体均值 <span class="math display">\[
\bar{Y}_i = \frac{1}{T} \sum_{t=1}^T Y_{it}, \quad \bar{T}_i = \frac{1}{T} \sum_{t=1}^T T_{it}, \quad \bar{X}_i = \frac{1}{T} \sum_{t=1}^T X_{it}
\]</span></p>
<p>第二步：进行组内变换 <span class="math display">\[
\tilde{Y}_{it} = Y_{it} - \bar{Y}_i, \quad \tilde{T}_{it} = T_{it} - \bar{T}_i, \quad \tilde{X}_{it} = X_{it} - \bar{X}_i
\]</span></p>
<p>第三步：估计变换后的模型 <span class="math display">\[
\tilde{Y}_{it} = \lambda_t + \beta \tilde{T}_{it} + \gamma' \tilde{X}_{it} + \tilde{\epsilon}_{it}
\]</span></p>
<p>其中时间固定效应<span class="math inline">\(\lambda_t\)</span>可以通过加入时间虚拟变量或进行时间均值差分来消除。</p>
<p><strong>一阶差分估计量（First-Difference Estimator）</strong></p>
<p>另一种常用方法是一阶差分法，特别适用于<span class="math inline">\(T=2\)</span>的情况：</p>
<p>差分变换: <span class="math display">\[
\Delta Y_i = Y_{i2} - Y_{i1}, \quad \Delta T_i = T_{i2} - T_{i1}, \quad \Delta X_i = X_{i2} - X_{i1}
\]</span></p>
<p>估计模型： <span class="math display">\[
\Delta Y_i = \beta \Delta T_i + \gamma' \Delta X_i + \Delta \epsilon_i
\]</span></p>
<p>一阶差分法同样消除了个体固定效应<span class="math inline">\(\alpha_i\)</span>。</p>
<p><strong>两种方法的比较</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 21%">
<col style="width: 21%">
<col style="width: 21%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th>方法</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>组内估计量</strong></td>
<td>效率高（使用所有变异）</td>
<td>需要严格外生性</td>
<td>平衡面板，<span class="math inline">\(T \geq 2\)</span></td>
</tr>
<tr class="even">
<td><strong>一阶差分</strong></td>
<td>对序列相关更稳健</td>
<td>损失信息，效率较低</td>
<td><span class="math inline">\(T=2\)</span>或担心严格外生性</td>
</tr>
</tbody>
</table>
</section>
<section id="固定效应模型的因果解释" class="level4">
<h4 class="anchored" data-anchor-id="固定效应模型的因果解释">6.8.3.4 固定效应模型的因果解释</h4>
<p><strong>处理效应的识别来源</strong></p>
<p>在固定效应模型中，处理效应<span class="math inline">\(\beta\)</span>的识别来源于<strong>个体内部</strong>处理状态的变化。具体来说：</p>
<ol type="1">
<li><strong>处理组个体</strong>：通过比较同一个体在处理前后的变化</li>
<li><strong>处理状态变化个体</strong>：通过比较个体从未处理到处理（或相反）的变化</li>
<li><strong>始终处理/未处理个体</strong>：不贡献于<span class="math inline">\(\beta\)</span>的识别（除非有处理效应异质性）</li>
</ol>
<p>这种识别策略被称为”<strong>利用个体内部变异</strong>”，其优势在于可以有效控制所有时不变的个体异质性。</p>
<p>图示说明：固定效应模型的识别机制</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    A[个体i的工资轨迹] --&gt; B{处理状态变化}
    B --&gt; C[处理前时期&lt;br/&gt;T_it=0]
    B --&gt; D[处理后时期&lt;br/&gt;T_it=1]
    
    C --&gt; E[观测结果: Y_it0]
    D --&gt; F[观测结果: Y_it1]
    
    E --&gt; G[反事实构造&lt;br/&gt;利用个体自身趋势]
    F --&gt; H[实际结果]
    
    G --&gt; I[个体内差分: ΔY_i = Y_it1 - Y_it0]
    H --&gt; I
    
    I --&gt; J[因果效应估计&lt;br/&gt;β = E[ΔY_i | ΔT_i=1] - E[ΔY_i | ΔT_i=0]]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p><strong>数学证明：固定效应模型的无偏性</strong></p>
<p>假设真实数据生成过程为： <span class="math display">\[
Y_{it} = \alpha_i + \lambda_t + \beta T_{it} + \theta' U_i + \gamma' X_{it} + \epsilon_{it}
\]</span> 其中<span class="math inline">\(U_i\)</span>为未观测的时不变混杂变量。</p>
<p>在组内变换后： <span class="math display">\[
\tilde{Y}_{it} = \lambda_t + \beta \tilde{T}_{it} + \gamma' \tilde{X}_{it} + \tilde{\epsilon}_{it}
\]</span></p>
<p>因为<span class="math inline">\(\tilde{U}_i = U_i - \bar{U}_i = 0\)</span>，未观测混杂<span class="math inline">\(U_i\)</span>被完全消除。只要<span class="math inline">\(\mathbb{E}[\tilde{\epsilon}_{it} | \tilde{T}_{it}, \tilde{X}_{it}] = 0\)</span>，<span class="math inline">\(\hat{\beta}\)</span>就是<span class="math inline">\(\beta\)</span>的无偏估计量。</p>
<p>** 主要局限性**</p>
<ol type="1">
<li><strong>时变混杂问题</strong>：固定效应只能消除时不变混杂，无法处理时变未观测混杂</li>
<li><strong>动态选择问题</strong>：如果处理决策基于过去的冲击（<span class="math inline">\(\epsilon_{i,t-1}\)</span>），严格外生性假设被违背</li>
<li><strong>处理效应异质性</strong>：如果处理效应因人而异，固定效应估计量可能不是有意义的平均</li>
<li><strong>测量误差偏误</strong>：组内变换可能放大测量误差的影响</li>
</ol>
<p><strong>解决方案</strong></p>
<ol type="1">
<li><p><strong>滞后因变量模型</strong>：控制滞后结果变量 <span class="math display">\[
Y_{it} = \alpha_i + \lambda_t + \rho Y_{i,t-1} + \beta T_{it} + \gamma' X_{it} + \epsilon_{it}
\]</span></p></li>
<li><p><strong>动态面板模型</strong>：使用GMM方法估计 <span class="math display">\[
Y_{it} = \alpha_i + \lambda_t + \rho Y_{i,t-1} + \beta T_{it} + \gamma' X_{it} + \epsilon_{it}
\]</span></p></li>
<li><p><strong>事件研究法</strong>：检验处理前后的动态效应 <span class="math display">\[
Y_{it} = \alpha_i + \lambda_t + \sum_{k=-K}^{-1} \beta_k \cdot D_{i,t+k} + \sum_{k=0}^{L} \beta_k \cdot D_{i,t+k} + \gamma' X_{it} + \epsilon_{it}
\]</span> 其中<span class="math inline">\(D_{i,t+k}\)</span>是个体<span class="math inline">\(i\)</span>在<span class="math inline">\(t+k\)</span>期是否处于处理期的虚拟变量。</p></li>
</ol>
<p>固定效应模型在以下情况下特别适用：</p>
<ol type="1">
<li><strong>面板数据可得</strong>：每个个体有多个时间点的观测</li>
<li><strong>主要混杂时不变</strong>：理论判断主要混杂变量不随时间变化</li>
<li><strong>处理状态变化</strong>：个体处理状态随时间发生变化</li>
<li><strong>平行趋势假设</strong>：在没有处理的情况下，处理组和对照组的趋势相同 ### 6.8.4 合成控制法：小样本政策评估</li>
</ol>
<p>合成控制法适用于处理单元较少（如一个州、一个国家）的政策评估问题：</p>
<p><strong>基本思想</strong>：从未受处理的供体单元中构造一个”合成控制组”，使其在处理前的特征和结果轨迹与处理单元尽可能相似。</p>
<p><strong>优化问题</strong>： <span class="math display">\[
\min_{w} \left\| X_1 - \sum_{j=2}^{J+1} w_j X_j \right\|_V
\quad \text{s.t.} \quad w_j \geq 0, \sum_{j=2}^{J+1} w_j = 1
\]</span></p>
<p>其中<span class="math inline">\(X_1\)</span>为处理单元的预处理特征向量，<span class="math inline">\(X_j\)</span>为供体单元的特征向量，<span class="math inline">\(V\)</span>为权重矩阵，<span class="math inline">\(w_j\)</span>为供体单元的权重。</p>
<p><strong>处理效应估计</strong>： <span class="math display">\[
\hat{\tau}_{1t} = Y_{1t} - \sum_{j=2}^{J+1} \hat{w}_j Y_{jt}, \quad t &gt; T_0
\]</span></p>
<p>其中<span class="math inline">\(T_0\)</span>为处理发生的时间。</p>
<p><strong>关键假设</strong>： 1. 供体池足够丰富，能够较好地拟合处理单元 2. 处理前拟合期足够长，能够捕捉趋势 3. 处理单元与合成控制组在处理前具有相似的特征和趋势</p>
<p><strong>推断方法</strong>：排列检验（Placebo Test）</p>
</section>
</section>
</section>
<section id="实证案例分析最低工资的就业效应" class="level2">
<h2 class="anchored" data-anchor-id="实证案例分析最低工资的就业效应">6.9 实证案例分析：最低工资的就业效应</h2>
<section id="研究背景与经典争议" class="level3">
<h3 class="anchored" data-anchor-id="研究背景与经典争议">6.9.1 研究背景与经典争议</h3>
<p>最低工资政策对就业的影响是劳动经济学中的经典问题。传统理论预测，提高最低工资会减少就业，但实证证据并不一致。</p>
</section>
<section id="card和krueger1994的自然实验" class="level3">
<h3 class="anchored" data-anchor-id="card和krueger1994的自然实验">6.9.2 Card和Krueger（1994）的自然实验</h3>
<p>Card和Krueger利用新泽西州提高最低工资而相邻的宾夕法尼亚州未提高的自然实验，采用双重差分法估计最低工资对快餐业就业的影响。</p>
</section>
<section id="研究设计与识别策略" class="level3">
<h3 class="anchored" data-anchor-id="研究设计与识别策略">6.9.3 研究设计与识别策略</h3>
<ol type="1">
<li><strong>处理组</strong>：新泽西州的快餐店</li>
<li><strong>对照组</strong>：宾夕法尼亚州的快餐店</li>
<li><strong>处理前后</strong>：1992年2月（政策前）和1992年11月（政策后）</li>
<li><strong>识别假设</strong>：平行趋势假设——如果没有最低工资提高，两州的就业趋势相同</li>
</ol>
</section>
<section id="stata操作演示目录" class="level3">
<h3 class="anchored" data-anchor-id="stata操作演示目录">6.9.4 Stata操作演示（目录）</h3>
<ul>
<li>6.9.4.1 数据导入与清理</li>
<li>6.9.4.2 描述性统计分析</li>
<li>6.9.4.3 平行趋势检验</li>
<li>6.9.4.4 双重差分估计</li>
<li>6.9.4.5 稳健性检验</li>
<li>6.9.4.6 结果可视化</li>
</ul>
</section>
<section id="r操作演示目录" class="level3">
<h3 class="anchored" data-anchor-id="r操作演示目录">6.9.5 R操作演示（目录）</h3>
<ul>
<li>6.9.5.1 数据准备与探索</li>
<li>6.9.5.2 使用<code>did</code>包进行DID估计</li>
<li>6.9.5.3 事件研究法实现</li>
<li>6.9.5.4 敏感性分析</li>
<li>6.9.5.5 结果报告与可视化</li>
</ul>
</section>
</section>
<section id="本章总结" class="level2">
<h2 class="anchored" data-anchor-id="本章总结">本章总结</h2>
<section id="核心概念体系回顾" class="level3">
<h3 class="anchored" data-anchor-id="核心概念体系回顾">核心概念体系回顾</h3>
<ol type="1">
<li><strong>潜在结果框架</strong>：定义了因果推断的基本语言和核心参数（ATE、ATT、ATC）</li>
<li><strong>根本问题</strong>：反事实结果的不可观测性是因果推断的根本障碍</li>
<li><strong>选择偏差</strong>：源于处理组和对照组在潜在结果上的系统性差异</li>
<li><strong>SUTVA假设</strong>：保证了处理效应的稳定性和可定义性</li>
<li><strong>非混杂性</strong>：观测研究中因果识别的核心假设</li>
<li><strong>内生性</strong>：计量经济学中的经典难题，有三个主要来源</li>
</ol>
</section>
<section id="方法体系梳理" class="level3">
<h3 class="anchored" data-anchor-id="方法体系梳理">方法体系梳理</h3>
<p>因果推断方法可以根据其识别策略分为五大类：</p>
<ol type="1">
<li><strong>实验方法</strong>：随机化实验是因果识别的黄金标准</li>
<li><strong>准实验方法</strong>：利用自然实验或制度设计模拟随机化（IV、RD）</li>
<li><strong>基于可忽略性方法</strong>：通过控制所有混杂变量识别因果效应（回归控制、匹配）</li>
<li><strong>面板数据方法</strong>：利用时间维度消除时不变混杂（FE、DID）</li>
<li><strong>合成控制方法</strong>：为小样本政策评估提供解决方案</li>
</ol>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    Start[研究问题] --&gt; Q1{能否随机化？}
    Q1 -- 能 --&gt; RCT[实施随机对照实验]
    Q1 -- 不能 --&gt; Q2{有无清晰断点？}
    
    Q2 -- 有 --&gt; RD[断点回归设计]
    Q2 -- 无 --&gt; Q3{有无自然实验工具？}
    
    Q3 -- 有 --&gt; IV[工具变量法&lt;br/&gt;检验：第一阶段F&gt;10]
    Q3 -- 无 --&gt; Q4{有无面板数据？}
    
    Q4 -- 有 --&gt; Q5{处理时点是否统一？}
    Q4 -- 无 --&gt; Q6{对照组是否明确？}
    
    Q5 -- 是 --&gt; DID[双重差分法&lt;br/&gt;检验：平行趋势]
    Q5 -- 否 --&gt; FE[固定效应模型&lt;br/&gt;检验：Hausman检验]
    
    Q6 -- 是 --&gt; PSM[倾向得分匹配&lt;br/&gt;检验：平衡性]
    Q6 -- 否 --&gt; SC[合成控制法&lt;br/&gt;检验：安慰剂检验]
    
    RCT &amp; RD &amp; IV &amp; DID &amp; FE &amp; PSM &amp; SC --&gt; Val[多方法三角验证&lt;br/&gt;+ 敏感性分析]
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="关键理论关系" class="level3">
<h3 class="anchored" data-anchor-id="关键理论关系">关键理论关系</h3>
<ol type="1">
<li><p><strong>随机化的作用</strong>： <span class="math display">\[
T_i \perp (Y_i(1), Y_i(0), X_i, U_i) \Rightarrow \text{无条件满足非混杂性}
\]</span></p></li>
<li><p><strong>线性回归的因果解释条件</strong>：</p>
<ul>
<li>随机化条件下：<span class="math inline">\(\mathbb{E}[\epsilon_i | T_i] = 0\)</span></li>
<li>非混杂性条件下：<span class="math inline">\(\mathbb{E}[\epsilon_i | T_i, X_i] = 0\)</span></li>
</ul></li>
<li><p><strong>固定效应模型的识别力量</strong>： <span class="math display">\[
Y_{it} = \alpha_i + \beta T_{it} + \epsilon_{it} \Rightarrow \text{消除所有时不变混杂}
\]</span></p></li>
</ol>
</section>
<section id="从理论到实践的桥梁" class="level3">
<h3 class="anchored" data-anchor-id="从理论到实践的桥梁">从理论到实践的桥梁</h3>
<p>本章建立的框架为后续章节的具体方法提供了理论基础：</p>
<ol type="1">
<li><strong>工具变量法（第7章）</strong>：通过寻找外生工具解决内生性问题</li>
<li><strong>断点回归（第8章）</strong>：利用制度断点创造局部随机化</li>
<li><strong>匹配方法（第9章）</strong>：基于可忽略性假设构造可比样本</li>
<li><strong>双重差分法（第10章）</strong>：结合面板数据和平行趋势假设</li>
<li><strong>合成控制法（第11章）</strong>：小样本政策评估的专门方法</li>
</ol>
</section>
<section id="实践指导原则" class="level3">
<h3 class="anchored" data-anchor-id="实践指导原则">实践指导原则</h3>
<p>在进行因果推断研究时，应遵循以下原则：</p>
<ol type="1">
<li><strong>透明性</strong>：明确陈述识别假设和可能违背</li>
<li><strong>稳健性</strong>：使用多种方法和设定检验结论的稳健性</li>
<li><strong>诚实性</strong>：承认研究的局限性，避免过度解读</li>
<li><strong>理论指导</strong>：基于经济理论选择变量和设定模型</li>
<li><strong>敏感性分析</strong>：评估结论对关键假设的敏感性</li>
</ol>
</section>
<section id="扩展思考" class="level3">
<h3 class="anchored" data-anchor-id="扩展思考">扩展思考</h3>
<ol type="1">
<li><strong>机器学习与因果推断</strong>：如何将机器学习方法用于协变量选择和模型设定？</li>
<li><strong>异质性处理效应</strong>：如何识别和处理效应的异质性？</li>
<li><strong>动态处理效应</strong>：如何处理处理效应的动态变化？</li>
<li><strong>溢出效应和一般均衡</strong>：如何放宽SUTVA假设？</li>
</ol>
<p>因果推断不仅是统计学和计量经济学的方法论，更是一种科学的思维方式。它要求我们从”是什么”（描述）转向”如果…会怎样”（因果），从被动观察转向主动思考。掌握这一框架，将使你能够更严谨地评估经济理论和政策效果，成为更优秀的经济学家。</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "已复制");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "已复制");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../chapters/5离散与受限因变量模型.html" class="pagination-link" aria-label="5 离散数据与受限因变量模型">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">5 离散数据与受限因变量模型</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../chapters/7工具变量法.html" class="pagination-link" aria-label="7 工具变量法">
        <span class="nav-page-text"><span class="chapter-title">7 工具变量法</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>