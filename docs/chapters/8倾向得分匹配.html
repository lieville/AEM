<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-Hans" xml:lang="zh-Hans"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.26">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<title>8 倾向得分匹配 – 计量模型及应用</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>

<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../chapters/9双重差分法.html" rel="next">
<link href="../chapters/7工具变量法.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-587c61ba64f3a5504c4d52d930310e48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-70a47bd5681a7291082a5b9f83d58762.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light"><script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "没有结果",
    "search-matching-documents-text": "匹配的文档",
    "search-copy-link-title": "复制搜索链接",
    "search-hide-matches-text": "隐藏其它匹配结果",
    "search-more-match-text": "更多匹配结果",
    "search-more-matches-text": "更多匹配结果",
    "search-clear-button-title": "清除",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "取消",
    "search-submit-button-title": "提交",
    "search-label": "搜索"
  }
}</script><script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script><script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script><link rel="stylesheet" href="science-textbook.css">
</head>
<body class="nav-sidebar floating quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><nav class="quarto-secondary-nav"><div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="展开或折叠侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/6因果推断框架.html">II 因果推断方法</a></li><li class="breadcrumb-item"><a href="../chapters/8倾向得分匹配.html"><span class="chapter-title">8 倾向得分匹配</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="展开或折叠侧边栏导航" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="搜索" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav></header><!-- content --><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto"><div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="../">计量模型及应用</a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="搜索"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">简介</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">说明</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true">
 <span class="menu-text">I 数据与模型</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="展开或折叠此栏">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/1线性回归.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">1 线性回归基础</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/2横截面数据分析.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">2 横截面数据：假设违反的诊断与修正</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/3面板数据模型.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">3 面板数据模型</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/4时间序列分析.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">4 时间序列分析</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/5离散与受限因变量模型.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">5 离散数据与受限因变量模型</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true">
 <span class="menu-text">II 因果推断方法</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="展开或折叠此栏">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/6因果推断框架.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">6 因果推断框架</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/7工具变量法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">7 工具变量法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/8倾向得分匹配.html" class="sidebar-item-text sidebar-link active"><span class="chapter-title">8 倾向得分匹配</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/9双重差分法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">9 双重差分法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/10断点回归.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">10 断点回归</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/11合成控制法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">11 合成控制法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/12回归控制法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">12 回归控制法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/13中介效应与调节效应.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">13 中介效应与调节效应</span></a>
  </div>
</li>
      </ul>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">III 理论与算法</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="展开或折叠此栏">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">
<li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/14大样本理论.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">14 大样本理论</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/15最大似然估计法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">15 最大似然估计理论</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/16广义矩估计法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">16 广义矩估计法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/17蒙特卡洛法与自助法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">17 蒙特卡洛法与自助法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/18优化算法与数值方法.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">18 数值优化与矩阵方法</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../chapters/19机器学习在计量中的应用.html" class="sidebar-item-text sidebar-link"><span class="chapter-title">19 机器学习在计量中的应用</span></a>
  </div>
</li>
      </ul>
</li>
    </ul>
</div>
</nav><div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active"><h2 id="toc-title">目录</h2>
   
  <ul>
<li><a href="#%E6%9C%AC%E7%AB%A0%E5%AF%BC%E8%AF%BB" id="toc-本章导读" class="nav-link active" data-scroll-target="#%E6%9C%AC%E7%AB%A0%E5%AF%BC%E8%AF%BB">本章导读</a></li>
  <li>
<a href="#%E9%80%89%E6%8B%A9%E5%81%8F%E5%B7%AE%E9%97%AE%E9%A2%98%E4%B8%8E%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E5%85%A5" id="toc-选择偏差问题与匹配方法的引入" class="nav-link" data-scroll-target="#%E9%80%89%E6%8B%A9%E5%81%8F%E5%B7%AE%E9%97%AE%E9%A2%98%E4%B8%8E%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%BC%95%E5%85%A5">8.1 选择偏差问题与匹配方法的引入</a>
  <ul class="collapse">
<li><a href="#%E8%A7%82%E5%AF%9F%E6%80%A7%E7%A0%94%E7%A9%B6%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E5%81%8F%E5%B7%AE%E4%BB%8E%E5%8F%8D%E4%BA%8B%E5%AE%9E%E6%A1%86%E6%9E%B6%E7%9C%8B%E6%AF%94%E8%BE%83%E7%BB%84%E7%9A%84%E4%B8%8D%E5%8F%AF%E6%AF%94%E6%80%A7" id="toc-观察性研究中的选择偏差从反事实框架看比较组的不可比性" class="nav-link" data-scroll-target="#%E8%A7%82%E5%AF%9F%E6%80%A7%E7%A0%94%E7%A9%B6%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E5%81%8F%E5%B7%AE%E4%BB%8E%E5%8F%8D%E4%BA%8B%E5%AE%9E%E6%A1%86%E6%9E%B6%E7%9C%8B%E6%AF%94%E8%BE%83%E7%BB%84%E7%9A%84%E4%B8%8D%E5%8F%AF%E6%AF%94%E6%80%A7">8.1.1 观察性研究中的选择偏差：从反事实框架看比较组的不可比性</a></li>
  <li><a href="#%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E6%9E%84%E9%80%A0%E5%B9%B3%E8%A1%A1%E5%8F%AF%E8%A7%82%E6%B5%8B%E7%89%B9%E5%BE%81%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%84" id="toc-匹配方法的基本逻辑构造平衡可观测特征的比较组" class="nav-link" data-scroll-target="#%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E9%80%BB%E8%BE%91%E6%9E%84%E9%80%A0%E5%B9%B3%E8%A1%A1%E5%8F%AF%E8%A7%82%E6%B5%8B%E7%89%B9%E5%BE%81%E7%9A%84%E6%AF%94%E8%BE%83%E7%BB%84">8.1.2 匹配方法的基本逻辑：构造平衡可观测特征的比较组</a></li>
  <li><a href="#%E7%BB%B4%E5%BA%A6%E8%AF%85%E5%92%92%E4%B8%8E%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E7%9A%84%E6%8F%90%E5%87%BA" id="toc-维度诅咒与倾向得分的提出" class="nav-link" data-scroll-target="#%E7%BB%B4%E5%BA%A6%E8%AF%85%E5%92%92%E4%B8%8E%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E7%9A%84%E6%8F%90%E5%87%BA">8.1.3 维度诅咒与倾向得分的提出</a></li>
  </ul>
</li>
  <li>
<a href="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E7%9A%84%E5%AE%9A%E4%B9%89%E6%80%A7%E8%B4%A8%E4%B8%8E%E4%BC%B0%E8%AE%A1" id="toc-倾向得分的定义性质与估计" class="nav-link" data-scroll-target="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E7%9A%84%E5%AE%9A%E4%B9%89%E6%80%A7%E8%B4%A8%E4%B8%8E%E4%BC%B0%E8%AE%A1">8.2 倾向得分的定义、性质与估计</a>
  <ul class="collapse">
<li><a href="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E7%9A%84%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E7%8E%87" id="toc-倾向得分的定义条件处理概率" class="nav-link" data-scroll-target="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E7%9A%84%E5%AE%9A%E4%B9%89%E6%9D%A1%E4%BB%B6%E5%A4%84%E7%90%86%E6%A6%82%E7%8E%87">8.2.1 倾向得分的定义：条件处理概率</a></li>
  <li><a href="#%E5%B9%B3%E8%A1%A1%E5%BE%97%E5%88%86%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%8F%AF%E5%BF%BD%E7%95%A5%E6%80%A7%E5%81%87%E8%AE%BE" id="toc-平衡得分性质与可忽略性假设" class="nav-link" data-scroll-target="#%E5%B9%B3%E8%A1%A1%E5%BE%97%E5%88%86%E6%80%A7%E8%B4%A8%E4%B8%8E%E5%8F%AF%E5%BF%BD%E7%95%A5%E6%80%A7%E5%81%87%E8%AE%BE">8.2.2 平衡得分性质与可忽略性假设</a></li>
  <li><a href="#%E5%85%B1%E5%90%8C%E6%94%AF%E6%8C%81%E5%9F%9F%E6%9D%A1%E4%BB%B6" id="toc-共同支持域条件" class="nav-link" data-scroll-target="#%E5%85%B1%E5%90%8C%E6%94%AF%E6%8C%81%E5%9F%9F%E6%9D%A1%E4%BB%B6">8.2.3 共同支持域条件</a></li>
  <li><a href="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E7%9A%84%E4%BC%B0%E8%AE%A1logit%E4%B8%8Eprobit%E6%A8%A1%E5%9E%8B" id="toc-倾向得分的估计logit与probit模型" class="nav-link" data-scroll-target="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E7%9A%84%E4%BC%B0%E8%AE%A1logit%E4%B8%8Eprobit%E6%A8%A1%E5%9E%8B">8.2.4 倾向得分的估计：Logit与Probit模型</a></li>
  </ul>
</li>
  <li>
<a href="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AE%9E%E6%96%BD%E6%AD%A5%E9%AA%A4" id="toc-倾向得分匹配的实施步骤" class="nav-link" data-scroll-target="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E5%8C%B9%E9%85%8D%E7%9A%84%E5%AE%9E%E6%96%BD%E6%AD%A5%E9%AA%A4">8.3 倾向得分匹配的实施步骤</a>
  <ul class="collapse">
<li><a href="#%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%BC%B0%E8%AE%A1%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E4%B8%8E%E6%A3%80%E9%AA%8C%E9%87%8D%E5%8F%A0%E6%80%A7" id="toc-第一步估计倾向得分与检验重叠性" class="nav-link" data-scroll-target="#%E7%AC%AC%E4%B8%80%E6%AD%A5%E4%BC%B0%E8%AE%A1%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E4%B8%8E%E6%A3%80%E9%AA%8C%E9%87%8D%E5%8F%A0%E6%80%A7">8.3.1 第一步：估计倾向得分与检验重叠性</a></li>
  <li><a href="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E9%80%89%E6%8B%A9%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95" id="toc-第二步选择匹配方法" class="nav-link" data-scroll-target="#%E7%AC%AC%E4%BA%8C%E6%AD%A5%E9%80%89%E6%8B%A9%E5%8C%B9%E9%85%8D%E6%96%B9%E6%B3%95">8.3.2 第二步：选择匹配方法</a></li>
  <li><a href="#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%8C%B9%E9%85%8D%E5%90%8E%E6%A0%B7%E6%9C%AC%E5%B9%B3%E8%A1%A1%E6%80%A7%E8%AF%8A%E6%96%AD" id="toc-第三步匹配后样本平衡性诊断" class="nav-link" data-scroll-target="#%E7%AC%AC%E4%B8%89%E6%AD%A5%E5%8C%B9%E9%85%8D%E5%90%8E%E6%A0%B7%E6%9C%AC%E5%B9%B3%E8%A1%A1%E6%80%A7%E8%AF%8A%E6%96%AD">8.3.3 第三步：匹配后样本平衡性诊断</a></li>
  <li><a href="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E4%BC%B0%E8%AE%A1%E5%A4%84%E7%90%86%E6%95%88%E5%BA%94%E4%B8%8E%E7%BB%9F%E8%AE%A1%E6%8E%A8%E6%96%AD" id="toc-第四步估计处理效应与统计推断" class="nav-link" data-scroll-target="#%E7%AC%AC%E5%9B%9B%E6%AD%A5%E4%BC%B0%E8%AE%A1%E5%A4%84%E7%90%86%E6%95%88%E5%BA%94%E4%B8%8E%E7%BB%9F%E8%AE%A1%E6%8E%A8%E6%96%AD">8.3.4 第四步：估计处理效应与统计推断</a></li>
  </ul>
</li>
  <li>
<a href="#%E5%8C%B9%E9%85%8D%E8%B4%A8%E9%87%8F%E7%9A%84%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%95%8F%E6%84%9F%E6%80%A7%E5%88%86%E6%9E%90" id="toc-匹配质量的诊断与敏感性分析" class="nav-link" data-scroll-target="#%E5%8C%B9%E9%85%8D%E8%B4%A8%E9%87%8F%E7%9A%84%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%95%8F%E6%84%9F%E6%80%A7%E5%88%86%E6%9E%90">8.4 匹配质量的诊断与敏感性分析</a>
  <ul class="collapse">
<li><a href="#%E5%B9%B3%E8%A1%A1%E6%80%A7%E6%A3%80%E9%AA%8C%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%AE%E5%BC%82t%E6%A3%80%E9%AA%8C%E4%B8%8E%E6%96%B9%E5%B7%AE%E6%AF%94" id="toc-平衡性检验标准化差异t检验与方差比" class="nav-link" data-scroll-target="#%E5%B9%B3%E8%A1%A1%E6%80%A7%E6%A3%80%E9%AA%8C%E6%A0%87%E5%87%86%E5%8C%96%E5%B7%AE%E5%BC%82t%E6%A3%80%E9%AA%8C%E4%B8%8E%E6%96%B9%E5%B7%AE%E6%AF%94">8.4.1 平衡性检验：标准化差异、t检验与方差比</a></li>
  <li><a href="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E5%88%86%E5%B8%83%E9%87%8D%E5%8F%A0%E5%9B%BE" id="toc-倾向得分分布重叠图" class="nav-link" data-scroll-target="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E5%88%86%E5%B8%83%E9%87%8D%E5%8F%A0%E5%9B%BE">8.4.2 倾向得分分布重叠图</a></li>
  <li><a href="#%E6%95%8F%E6%84%9F%E6%80%A7%E5%88%86%E6%9E%90%E8%AF%84%E4%BC%B0%E6%9C%AA%E8%A7%82%E6%B5%8B%E6%B7%B7%E6%9D%82%E5%9B%A0%E7%B4%A0%E7%9A%84%E5%BD%B1%E5%93%8D" id="toc-敏感性分析评估未观测混杂因素的影响" class="nav-link" data-scroll-target="#%E6%95%8F%E6%84%9F%E6%80%A7%E5%88%86%E6%9E%90%E8%AF%84%E4%BC%B0%E6%9C%AA%E8%A7%82%E6%B5%8B%E6%B7%B7%E6%9D%82%E5%9B%A0%E7%B4%A0%E7%9A%84%E5%BD%B1%E5%93%8D">8.4.3 敏感性分析：评估未观测混杂因素的影响</a></li>
  </ul>
</li>
  <li>
<a href="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A9%E5%B1%95" id="toc-倾向得分方法的扩展" class="nav-link" data-scroll-target="#%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A9%E5%B1%95">8.5 倾向得分方法的扩展</a>
  <ul class="collapse">
<li><a href="#%E9%80%86%E6%A6%82%E7%8E%87%E5%8A%A0%E6%9D%83%E6%B3%95" id="toc-逆概率加权法" class="nav-link" data-scroll-target="#%E9%80%86%E6%A6%82%E7%8E%87%E5%8A%A0%E6%9D%83%E6%B3%95">8.5.1 逆概率加权法</a></li>
  <li><a href="#%E5%8F%8C%E9%87%8D%E7%A8%B3%E5%81%A5%E4%BC%B0%E8%AE%A1" id="toc-双重稳健估计" class="nav-link" data-scroll-target="#%E5%8F%8C%E9%87%8D%E7%A8%B3%E5%81%A5%E4%BC%B0%E8%AE%A1">8.5.2 双重稳健估计</a></li>
  <li><a href="#%E5%B9%BF%E4%B9%89%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F%E8%BF%9E%E7%BB%AD%E6%88%96%E5%A4%9A%E5%80%BC" id="toc-广义倾向得分处理变量连续或多值" class="nav-link" data-scroll-target="#%E5%B9%BF%E4%B9%89%E5%80%BE%E5%90%91%E5%BE%97%E5%88%86%E5%A4%84%E7%90%86%E5%8F%98%E9%87%8F%E8%BF%9E%E7%BB%AD%E6%88%96%E5%A4%9A%E5%80%BC">8.5.3 广义倾向得分（处理变量连续或多值）</a></li>
  <li><a href="#%E8%BE%B9%E9%99%85%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B" id="toc-边际结构模型简介" class="nav-link" data-scroll-target="#%E8%BE%B9%E9%99%85%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B">8.5.4 边际结构模型简介</a></li>
  </ul>
</li>
  <li>
<a href="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E4%B8%8E%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5" id="toc-应用实例与操作实践" class="nav-link" data-scroll-target="#%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E4%B8%8E%E6%93%8D%E4%BD%9C%E5%AE%9E%E8%B7%B5">8.6 应用实例与操作实践</a>
  <ul class="collapse">
<li><a href="#%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%E5%8A%B3%E5%8A%A8%E5%8A%9B%E5%B8%82%E5%9C%BA%E5%9F%B9%E8%AE%AD%E9%A1%B9%E7%9B%AE%E8%AF%84%E4%BC%B0" id="toc-经典案例劳动力市场培训项目评估" class="nav-link" data-scroll-target="#%E7%BB%8F%E5%85%B8%E6%A1%88%E4%BE%8B%E5%8A%B3%E5%8A%A8%E5%8A%9B%E5%B8%82%E5%9C%BA%E5%9F%B9%E8%AE%AD%E9%A1%B9%E7%9B%AE%E8%AF%84%E4%BC%B0">8.6.1 经典案例：劳动力市场培训项目评估</a></li>
  <li><a href="#%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9Cstata-psmatch2-teffects-%E4%B8%8E-r-matchit-weightit" id="toc-软件操作stata-psmatch2-teffects-与-r-matchit-weightit" class="nav-link" data-scroll-target="#%E8%BD%AF%E4%BB%B6%E6%93%8D%E4%BD%9Cstata-psmatch2-teffects-%E4%B8%8E-r-matchit-weightit">8.6.2 软件操作：Stata (<code>psmatch2</code>, <code>teffects</code>) 与 R (<code>MatchIt</code>, <code>WeightIt</code>)</a></li>
  <li><a href="#%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A%E8%A7%84%E8%8C%83%E4%B8%8E%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA" id="toc-研究报告规范与常见误区" class="nav-link" data-scroll-target="#%E7%A0%94%E7%A9%B6%E6%8A%A5%E5%91%8A%E8%A7%84%E8%8C%83%E4%B8%8E%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA">8.6.3 研究报告规范与常见误区</a></li>
  </ul>
</li>
  <li><a href="#%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93" id="toc-本章总结" class="nav-link" data-scroll-target="#%E6%9C%AC%E7%AB%A0%E6%80%BB%E7%BB%93">本章总结</a></li>
  </ul></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content"><header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../chapters/6因果推断框架.html">II 因果推断方法</a></li><li class="breadcrumb-item"><a href="../chapters/8倾向得分匹配.html"><span class="chapter-title">8 倾向得分匹配</span></a></li></ol></nav><div class="quarto-title">
<h1 class="title"><span class="chapter-title">8 倾向得分匹配</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header><section id="本章导读" class="level2"><h2 class="anchored" data-anchor-id="本章导读">本章导读</h2>
<p>倾向得分匹配是处理观察性数据中由<strong>可观测混杂因素</strong>导致的选择偏差的核心方法。当个体是否接受某项处理并非随机分配，而是依赖于可观测的特征变量时，处理组和对照组在这些特征上的不平衡分布会导致简单的均值比较产生偏误。本章将系统介绍倾向得分匹配的基本原理，该方法通过为每个处理组个体寻找特征相似的对照组个体，构造”近似可比”的比较组，从而在观察性研究中模拟随机实验的平衡性特征。我们将详细讲解倾向得分的估计、匹配方法的实施、匹配质量的诊断以及前沿的扩展方法。</p>
</section><section id="选择偏差问题与匹配方法的引入" class="level2"><h2 class="anchored" data-anchor-id="选择偏差问题与匹配方法的引入">8.1 选择偏差问题与匹配方法的引入</h2>
<section id="观察性研究中的选择偏差从反事实框架看比较组的不可比性" class="level3"><h3 class="anchored" data-anchor-id="观察性研究中的选择偏差从反事实框架看比较组的不可比性">8.1.1 观察性研究中的选择偏差：从反事实框架看比较组的不可比性</h3>
<p>在观察性研究中，个体是否接受处理通常不是随机的，而是基于可观测（有时是不可观测）的特征进行自我选择或被选择。这导致处理组和对照组在潜在结果分布上存在系统性差异，即<strong>选择偏差</strong>。</p>
<p><strong>反事实框架下的选择偏差</strong>： 考虑处理效应<span class="math inline">\(ATT = E[Y_i(1) - Y_i(0) | D_i=1]\)</span>，我们能够观测到的是： <span class="math display">\[
E[Y_i | D_i=1] - E[Y_i | D_i=0] = ATT + \underbrace{E[Y_i(0) | D_i=1] - E[Y_i(0) | D_i=0]}_{\text{选择偏差}}
\]</span></p>
<p>如果选择偏差不为零，简单的组间均值比较不能无偏地估计处理效应。选择偏差的根源在于处理组和对照组在未处理状态下的潜在结果均值不同。</p>
<p><strong>可观测选择偏差</strong>： 当选择机制完全由可观测特征<span class="math inline">\(X_i\)</span>决定时，即满足<strong>条件独立性假设</strong>： <span class="math display">\[
(Y_i(1), Y_i(0)) \perp D_i | X_i
\]</span></p>
<p>在这种情况下，选择偏差完全由可观测特征<span class="math inline">\(X_i\)</span>的分布差异导致，可以通过统计方法进行调整。</p>
</section><section id="匹配方法的基本逻辑构造平衡可观测特征的比较组" class="level3"><h3 class="anchored" data-anchor-id="匹配方法的基本逻辑构造平衡可观测特征的比较组">8.1.2 匹配方法的基本逻辑：构造平衡可观测特征的比较组</h3>
<p>匹配方法的核心思想是：对于每个处理组个体，从对照组中寻找一个或多个具有相似可观测特征的个体，用这些匹配个体的结果作为该处理组个体的反事实结果的近似。</p>
<p><strong>精确匹配</strong>： 最理想的情况是精确匹配，即对于每个处理组个体，找到在<span class="math inline">\(X_i\)</span>上完全相同的对照组个体。但这种方法在实际中往往不可行，因为： 1. <span class="math inline">\(X_i\)</span>通常是连续变量或多维变量，精确匹配很难实现 2. 即使找到精确匹配，样本量会急剧减少</p>
<p><strong>近似匹配</strong>： 在实践中，我们进行近似匹配，即寻找<span class="math inline">\(X_i\)</span>上”相似”的个体。衡量相似性的方法包括： 1. 马氏距离：<span class="math inline">\((X_i - X_j)'\Sigma^{-1}(X_i - X_j)\)</span> 2. 欧氏距离：<span class="math inline">\(\|X_i - X_j\|\)</span> 3. 倾向得分距离：<span class="math inline">\(|p(X_i) - p(X_j)|\)</span></p>
</section><section id="维度诅咒与倾向得分的提出" class="level3"><h3 class="anchored" data-anchor-id="维度诅咒与倾向得分的提出">8.1.3 维度诅咒与倾向得分的提出</h3>
<p>当可观测特征<span class="math inline">\(X_i\)</span>的维度较高时，直接基于<span class="math inline">\(X_i\)</span>进行匹配会遇到<strong>维度诅咒</strong>问题：随着维度增加，找到足够相似的匹配对象变得越来越困难。</p>
<p><strong>Rosenbaum和Rubin（1983）的突破</strong>： Rosenbaum和Rubin证明，如果条件独立性假设成立，那么匹配可以基于一维的<strong>倾向得分</strong><span class="math inline">\(p(X_i) = P(D_i=1|X_i)\)</span>进行，而无需基于高维的<span class="math inline">\(X_i\)</span>。这是因为倾向得分具有以下重要性质： 1. <strong>平衡性</strong>：在给定<span class="math inline">\(p(X_i)\)</span>的条件下，<span class="math inline">\(D_i\)</span>与<span class="math inline">\(X_i\)</span>独立 2. <strong>可忽略性</strong>：在给定<span class="math inline">\(p(X_i)\)</span>的条件下，<span class="math inline">\((Y_i(1), Y_i(0))\)</span>与<span class="math inline">\(D_i\)</span>独立</p>
<p>因此，基于倾向得分的匹配可以达到与基于<span class="math inline">\(X_i\)</span>的匹配相同的平衡效果，同时避免了维度诅咒问题。</p>
</section></section><section id="倾向得分的定义性质与估计" class="level2"><h2 class="anchored" data-anchor-id="倾向得分的定义性质与估计">8.2 倾向得分的定义、性质与估计</h2>
<section id="倾向得分的定义条件处理概率" class="level3"><h3 class="anchored" data-anchor-id="倾向得分的定义条件处理概率">8.2.1 倾向得分的定义：条件处理概率</h3>
<p>倾向得分定义为给定可观测特征<span class="math inline">\(X_i\)</span>的条件下，个体接受处理的概率： <span class="math display">\[
p(X_i) = P(D_i=1|X_i) = E[D_i|X_i]
\]</span></p>
<p>倾向得分是一个介于0和1之间的数值，反映了在观察到<span class="math inline">\(X_i\)</span>的情况下，个体接受处理的可能性。</p>
<p><strong>倾向得分的解释</strong>： - 倾向得分接近1：具有特征<span class="math inline">\(X_i\)</span>的个体几乎肯定接受处理 - 倾向得分接近0：具有特征<span class="math inline">\(X_i\)</span>的个体几乎肯定不接受处理 - 倾向得分在中间范围：接受处理与否有一定不确定性</p>
</section><section id="平衡得分性质与可忽略性假设" class="level3"><h3 class="anchored" data-anchor-id="平衡得分性质与可忽略性假设">8.2.2 平衡得分性质与可忽略性假设</h3>
<p><strong>平衡得分</strong>： 平衡得分<span class="math inline">\(b(X)\)</span>是<span class="math inline">\(X\)</span>的任意函数，使得在给定<span class="math inline">\(b(X)\)</span>的条件下，处理分配<span class="math inline">\(D\)</span>与特征<span class="math inline">\(X\)</span>独立： <span class="math display">\[
D \perp X | b(X)
\]</span></p>
<p><strong>定理（Rosenbaum和Rubin，1983）</strong>： 倾向得分<span class="math inline">\(p(X)\)</span>是一个平衡得分。事实上，它是最粗糙的平衡得分（即包含信息最少但足以达到平衡）。</p>
<p><strong>可忽略性假设</strong>： 如果条件独立性假设在<span class="math inline">\(X\)</span>条件下成立，那么在任意平衡得分<span class="math inline">\(b(X)\)</span>条件下也成立： <span class="math display">\[
(Y(1), Y(0)) \perp D | X \Rightarrow (Y(1), Y(0)) \perp D | b(X)
\]</span></p>
<p>特别地，在倾向得分<span class="math inline">\(p(X)\)</span>条件下： <span class="math display">\[
(Y(1), Y(0)) \perp D | p(X)
\]</span></p>
<p>这意味着，如果两组个体具有相同的倾向得分，那么他们的处理分配可以视为近似随机的，他们的潜在结果分布应该相似。</p>
</section><section id="共同支持域条件" class="level3"><h3 class="anchored" data-anchor-id="共同支持域条件">8.2.3 共同支持域条件</h3>
<p>共同支持域是指处理组和对照组的倾向得分分布有重叠的区域。形式化地，共同支持域定义为： <span class="math display">\[
S = \{p: 0 &lt; f(p|D=1) \text{ 且 } 0 &lt; f(p|D=0)\}
\]</span> 其中<span class="math inline">\(f(p|D=d)\)</span>是倾向得分在组<span class="math inline">\(d\)</span>中的密度函数。</p>
<p><strong>实际操作中的共同支持域</strong>： 我们通常要求： <span class="math display">\[
0 &lt; p(X_i) &lt; 1 \quad \text{对于所有} X_i
\]</span></p>
<p>在实践中，我们检查并确保： 1. 处理组和对照组的倾向得分分布有显著重叠 2. 没有个体具有极端倾向得分（如接近0或1）</p>
<p><strong>样本修剪</strong>： 如果存在极端倾向得分的个体，通常的做法是进行样本修剪，即删除倾向得分超出共同范围的个体。虽然这减少了样本量，但可以提高匹配质量，减少外推偏差。</p>
</section><section id="倾向得分的估计logit与probit模型" class="level3"><h3 class="anchored" data-anchor-id="倾向得分的估计logit与probit模型">8.2.4 倾向得分的估计：Logit与Probit模型</h3>
<p>倾向得分通常通过参数模型估计，最常用的是Logit和Probit模型。</p>
<p><strong>Logit模型</strong>： <span class="math display">\[
p(X_i) = \frac{\exp(X_i'\beta)}{1+\exp(X_i'\beta)}
\]</span> 其中<span class="math inline">\(\beta\)</span>是系数向量，通过最大似然估计得到。</p>
<p><strong>Probit模型</strong>： <span class="math display">\[
p(X_i) = \Phi(X_i'\beta)
\]</span> 其中<span class="math inline">\(\Phi(\cdot)\)</span>是标准正态累积分布函数。</p>
<p><strong>模型选择与设定</strong>： 1. 应该包含所有同时影响处理状态和结果变量的协变量 2. 可以考虑高阶项（平方项、交互项）以改善平衡性 3. 不应包含仅影响结果但不影响处理状态的变量（这不会改善平衡性，但可能增加方差） 4. 不应包含仅影响处理状态但不影响结果的变量（这可能导致”坏控制”问题）</p>
<p><strong>模型诊断</strong>： 1. 伪R²：衡量模型拟合优度，但高伪R²不一定表示好的平衡性 2. 预测概率的分布：检查是否有很多接近0或1的预测值 3. Hosmer-Lemeshow检验：检验预测概率与实际处理比例的一致性</p>
</section></section><section id="倾向得分匹配的实施步骤" class="level2"><h2 class="anchored" data-anchor-id="倾向得分匹配的实施步骤">8.3 倾向得分匹配的实施步骤</h2>
<section id="第一步估计倾向得分与检验重叠性" class="level3"><h3 class="anchored" data-anchor-id="第一步估计倾向得分与检验重叠性">8.3.1 第一步：估计倾向得分与检验重叠性</h3>
<p><strong>估计倾向得分</strong>： 使用Logit或Probit模型估计每个个体的倾向得分<span class="math inline">\(\hat{p}(X_i)\)</span>。</p>
<p><strong>检验重叠性</strong>： 1. 绘制处理组和对照组的倾向得分分布图（直方图或核密度图） 2. 计算倾向得分的描述性统计量（最小值、最大值、分位数） 3. 确定共同支持域：通常删除倾向得分小于对照组最大值且大于处理组最小值的个体，或删除分布两端一定比例（如1%或5%）的个体</p>
<p><strong>重叠性图形示例</strong>：</p>
<div class="cell">
<div class="code-copy-outer-scaffold"><div class="sourceCode cell-code" id="cb1"><pre class="sourceCode numberSource r number-lines code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="co"># R代码示例：绘制倾向得分分布图</span></span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="fu">library</span>(ggplot2)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="fu">ggplot</span>(data, <span class="fu">aes</span>(<span class="at">x=</span>pscore, <span class="at">fill=</span>treat)) <span class="sc">+</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>  <span class="fu">geom_density</span>(<span class="at">alpha=</span><span class="fl">0.5</span>) <span class="sc">+</span></span>
<span id="cb1-5"><a href="#cb1-5"></a>  <span class="fu">labs</span>(<span class="at">x=</span><span class="st">"Propensity Score"</span>, <span class="at">y=</span><span class="st">"Density"</span>, <span class="at">fill=</span><span class="st">"Treatment"</span>)</span></code></pre></div><button title="复制到剪贴板" class="code-copy-button"><i class="bi"></i></button></div>
</div>
</section><section id="第二步选择匹配方法" class="level3"><h3 class="anchored" data-anchor-id="第二步选择匹配方法">8.3.2 第二步：选择匹配方法</h3>
<p>常用的匹配方法包括：</p>
<p><strong>最近邻匹配</strong>： 为每个处理组个体寻找倾向得分最接近的一个或多个对照组个体。 - 一对一匹配：每个处理组个体匹配一个最接近的对照组个体 - 一对多匹配：每个处理组个体匹配k个最接近的对照组个体 - 有放回 vs.&nbsp;无放回：有放回允许对照组个体被多次匹配，通常能提高匹配质量</p>
<p><strong>卡尺匹配</strong>： 要求匹配个体的倾向得分差异不超过预设的阈值（卡尺）。卡尺通常设定为倾向得分标准差的0.2-0.25倍。</p>
<p><strong>半径匹配</strong>： 为每个处理组个体匹配所有在卡尺内的对照组个体，这些对照组个体获得相等的权重。</p>
<p><strong>核匹配</strong>： 使用所有对照组个体进行匹配，但根据倾向得分差异给予不同权重。权重由核函数<span class="math inline">\(K(\cdot)\)</span>决定： <span class="math display">\[
w_{ij} = \frac{K\left(\frac{\hat{p}(X_j) - \hat{p}(X_i)}{h}\right)}{\sum_{k:D_k=0} K\left(\frac{\hat{p}(X_k) - \hat{p}(X_i)}{h}\right)}
\]</span> 其中<span class="math inline">\(h\)</span>是带宽参数。</p>
<p><strong>匹配方法的选择考量</strong>： 1. 偏差-方差权衡：更严格的匹配（如一对一）可能减少偏差但增加方差 2. 计算复杂性：核匹配通常计算量更大 3. 样本利用率：半径匹配和核匹配利用了更多对照组信息</p>
</section><section id="第三步匹配后样本平衡性诊断" class="level3"><h3 class="anchored" data-anchor-id="第三步匹配后样本平衡性诊断">8.3.3 第三步：匹配后样本平衡性诊断</h3>
<p>匹配后需要检验处理组和匹配后的对照组在可观测特征上是否平衡。</p>
<p><strong>标准化差异</strong>： 对于每个协变量<span class="math inline">\(X_k\)</span>，计算标准化差异： <span class="math display">\[
SD_k = \frac{\bar{X}_{k,treated} - \bar{X}_{k,matched\_control}}{\sqrt{(s_{k,treated}^2 + s_{k,matched\_control}^2)/2}}
\]</span> 其中<span class="math inline">\(\bar{X}\)</span>是均值，<span class="math inline">\(s^2\)</span>是方差。</p>
<p>经验上，匹配后所有协变量的标准化差异应小于0.1（理想情况下小于0.05）。</p>
<p><strong>方差比</strong>： 对于每个协变量<span class="math inline">\(X_k\)</span>，计算处理组和匹配对照组的方差比： <span class="math display">\[
VR_k = \frac{s_{k,treated}^2}{s_{k,matched\_control}^2}
\]</span> 匹配后，方差比应接近1（如0.8-1.25之间）。</p>
<p><strong>t检验</strong>： 对每个协变量进行两组均值差异的t检验。匹配后，这些检验应不再显著（p值&gt;0.05）。</p>
</section><section id="第四步估计处理效应与统计推断" class="level3"><h3 class="anchored" data-anchor-id="第四步估计处理效应与统计推断">8.3.4 第四步：估计处理效应与统计推断</h3>
<p><strong>处理效应估计</strong>： 匹配后，处理效应可以通过比较处理组和匹配对照组的结果均值来估计。对于一对一匹配： <span class="math display">\[
\hat{\tau}_{ATT} = \frac{1}{N_1} \sum_{i:D_i=1} \left[Y_i - \frac{1}{M}\sum_{j\in J_M(i)} Y_j\right]
\]</span> 其中<span class="math inline">\(J_M(i)\)</span>是处理组个体<span class="math inline">\(i\)</span>的<span class="math inline">\(M\)</span>个匹配的对照组个体集合。</p>
<p>对于核匹配： <span class="math display">\[
\hat{\tau}_{ATT} = \frac{1}{N_1} \sum_{i:D_i=1} \left[Y_i - \frac{\sum_{j:D_j=0} w_{ij} Y_j}{\sum_{j:D_j=0} w_{ij}}\right]
\]</span></p>
<p><strong>统计推断</strong>： 由于倾向得分是估计得到的，且匹配过程引入了相关性，传统的标准误计算可能不正确。常用的方法包括： 1. <strong>自助法</strong>：对原始样本进行重复抽样，每次重新估计倾向得分并进行匹配 2. <strong>Abadie-Imbens标准误</strong>：考虑了匹配不确定性的解析标准误 3. <strong>稳健标准误公式</strong>：基于匹配后样本计算的稳健标准误</p>
<p><strong>自助法步骤</strong>： 1. 从原始样本中有放回地抽取一个自助样本 2. 在自助样本中重新估计倾向得分 3. 基于新的倾向得分重新进行匹配 4. 计算处理效应估计值 5. 重复B次（如500次），得到处理效应的自助分布 6. 基于自助分布计算标准误和置信区间</p>
</section></section><section id="匹配质量的诊断与敏感性分析" class="level2"><h2 class="anchored" data-anchor-id="匹配质量的诊断与敏感性分析">8.4 匹配质量的诊断与敏感性分析</h2>
<section id="平衡性检验标准化差异t检验与方差比" class="level3"><h3 class="anchored" data-anchor-id="平衡性检验标准化差异t检验与方差比">8.4.1 平衡性检验：标准化差异、t检验与方差比</h3>
<p><strong>平衡性检验表</strong>： 研究报告应包含匹配前后的平衡性检验表，展示： 1. 每个协变量的处理组和对照组均值 2. 标准化差异（匹配前后） 3. 方差比（匹配前后） 4. t检验的p值（匹配前后）</p>
<p><strong>可视化平衡性改进</strong>： 可以绘制匹配前后标准化差异的图形，直观展示平衡性的改善。</p>
<p><strong>经验准则</strong>： - 所有协变量的匹配后标准化差异应&lt;0.1 - 至少90%的协变量的标准化差异应&lt;0.05 - 方差比应在0.8-1.25之间 - t检验的p值应&gt;0.05</p>
</section><section id="倾向得分分布重叠图" class="level3"><h3 class="anchored" data-anchor-id="倾向得分分布重叠图">8.4.2 倾向得分分布重叠图</h3>
<p><strong>分布重叠图</strong>： 绘制处理组和对照组（匹配前后）的倾向得分分布图，直观展示： 1. 匹配前两组分布的差异 2. 匹配后两组分布的相似性 3. 共同支持域的范围</p>
<p><strong>分位数-分位数图</strong>： 绘制处理组和对照组倾向得分分位数的Q-Q图，如果点在45度线附近，说明两组分布相似。</p>
</section><section id="敏感性分析评估未观测混杂因素的影响" class="level3"><h3 class="anchored" data-anchor-id="敏感性分析评估未观测混杂因素的影响">8.4.3 敏感性分析：评估未观测混杂因素的影响</h3>
<p>倾向得分匹配只能控制可观测的混杂因素。如果存在未观测的混杂因素，估计结果可能仍有偏误。敏感性分析用于评估这种可能性。</p>
<p><strong>Rosenbaum界限方法</strong>： 该方法评估需要多大的未观测混杂因素才能推翻研究结论。设<span class="math inline">\(\Gamma\)</span>表示未观测混杂因素的最大影响，定义为两个具有相同可观测特征的个体接受处理概率的最大比值。</p>
<p><strong>敏感性分析步骤</strong>： 1. 对于不同的<span class="math inline">\(\Gamma\)</span>值（如1.5, 2.0, 2.5），计算处理效应的置信区间 2. 确定使结论变得不显著的<span class="math inline">\(\Gamma\)</span>值 3. 评估这样的<span class="math inline">\(\Gamma\)</span>值是否合理</p>
<p><strong>经验解释</strong>： 如果较小的<span class="math inline">\(\Gamma\)</span>（如<span class="math inline">\(\Gamma=1.5\)</span>）就能使结论变得不显著，说明结果对未观测混杂因素敏感。如果较大的<span class="math inline">\(\Gamma\)</span>（如<span class="math inline">\(\Gamma=3.0\)</span>）才能使结论不显著，说明结果相对稳健。</p>
</section></section><section id="倾向得分方法的扩展" class="level2"><h2 class="anchored" data-anchor-id="倾向得分方法的扩展">8.5 倾向得分方法的扩展</h2>
<section id="逆概率加权法" class="level3"><h3 class="anchored" data-anchor-id="逆概率加权法">8.5.1 逆概率加权法</h3>
<p>逆概率加权法不进行匹配，而是通过加权使处理组和对照组在特征分布上平衡。</p>
<p><strong>ATE的IPW估计量</strong>： <span class="math display">\[
\hat{\tau}_{ATE}^{IPW} = \frac{1}{N}\sum_{i=1}^N \left[\frac{D_i Y_i}{\hat{p}(X_i)} - \frac{(1-D_i)Y_i}{1-\hat{p}(X_i)}\right]
\]</span></p>
<p><strong>ATT的IPW估计量</strong>： <span class="math display">\[
\hat{\tau}_{ATT}^{IPW} = \frac{1}{\sum_{i=1}^N D_i} \sum_{i=1}^N D_i Y_i - \frac{1}{\sum_{i=1}^N D_i} \sum_{i=1}^N \frac{D_i \hat{p}(X_i)(1-D_i)Y_i}{1-\hat{p}(X_i)}
\]</span></p>
<p><strong>优点与缺点</strong>： - 优点：使用了所有样本，比匹配更有效率 - 缺点：对倾向得分模型设定敏感，特别是当倾向得分接近0或1时，权重会变得很大，导致估计不稳定</p>
</section><section id="双重稳健估计" class="level3"><h3 class="anchored" data-anchor-id="双重稳健估计">8.5.2 双重稳健估计</h3>
<p>双重稳健估计结合了倾向得分加权和结果回归，只要其中一个模型正确设定，就能得到一致估计。</p>
<p><strong>DR估计量</strong>： <span class="math display">\[
\hat{\tau}_{DR} = \frac{1}{N}\sum_{i=1}^N \left[\frac{D_i(Y_i - \hat{m}_1(X_i))}{\hat{p}(X_i)} + \hat{m}_1(X_i)\right] - \frac{1}{N}\sum_{i=1}^N \left[\frac{(1-D_i)(Y_i - \hat{m}_0(X_i))}{1-\hat{p}(X_i)} + \hat{m}_0(X_i)\right]
\]</span> 其中<span class="math inline">\(\hat{m}_1(X_i) = E[Y_i|D_i=1, X_i]\)</span>和<span class="math inline">\(\hat{m}_0(X_i) = E[Y_i|D_i=0, X_i]\)</span>是通过回归模型估计的。</p>
<p><strong>优点</strong>： 对模型误设更稳健，且通常比单独的匹配或IPW更有效。</p>
</section><section id="广义倾向得分处理变量连续或多值" class="level3"><h3 class="anchored" data-anchor-id="广义倾向得分处理变量连续或多值">8.5.3 广义倾向得分（处理变量连续或多值）</h3>
<p>当处理变量是连续或多值时，可以使用广义倾向得分方法。</p>
<p><strong>连续处理情况</strong>： 对于连续处理<span class="math inline">\(T_i\)</span>，广义倾向得分定义为处理变量的条件密度： <span class="math display">\[
r(t, X_i) = f_{T|X}(t|X_i)
\]</span></p>
<p><strong>剂量反应函数</strong>： 剂量反应函数<span class="math inline">\(\mu(t) = E[Y_i(t)]\)</span>可以通过逆概率加权估计： <span class="math display">\[
\hat{\mu}(t) = \frac{1}{N}\sum_{i=1}^N \frac{K_h(T_i - t)Y_i}{r(t, X_i)}
\]</span> 其中<span class="math inline">\(K_h(\cdot)\)</span>是核函数，<span class="math inline">\(h\)</span>是带宽。</p>
</section><section id="边际结构模型简介" class="level3"><h3 class="anchored" data-anchor-id="边际结构模型简介">8.5.4 边际结构模型简介</h3>
<p>边际结构模型通过逆概率加权估计边际处理效应，特别适用于处理随时间变化的情况。</p>
<p><strong>时变处理</strong>： 设<span class="math inline">\(T\)</span>个时期的处理序列为<span class="math inline">\(\bar{D} = (D_1, ..., D_T)\)</span>，协变量序列为<span class="math inline">\(\bar{X} = (X_1, ..., X_T)\)</span>。每个时期的权重为： <span class="math display">\[
w_i = \prod_{t=1}^T \frac{1}{P(D_t=d_t|\bar{D}_{t-1}=\bar{d}_{t-1}, \bar{X}_t=\bar{x}_t)}
\]</span></p>
<p><strong>MSM模型</strong>： 估计边际结构模型： <span class="math display">\[
E[Y(\bar{d})] = \beta_0 + \beta_1 \text{cum}(\bar{d})
\]</span> 其中<span class="math inline">\(\text{cum}(\bar{d})\)</span>是累计处理量。</p>
<p><strong>优点</strong>： 能处理时变混杂因素，但需要正确设定每个时期的倾向得分模型。</p>
</section></section><section id="应用实例与操作实践" class="level2"><h2 class="anchored" data-anchor-id="应用实例与操作实践">8.6 应用实例与操作实践</h2>
<section id="经典案例劳动力市场培训项目评估" class="level3"><h3 class="anchored" data-anchor-id="经典案例劳动力市场培训项目评估">8.6.1 经典案例：劳动力市场培训项目评估</h3>
</section><section id="软件操作stata-psmatch2-teffects-与-r-matchit-weightit" class="level3"><h3 class="anchored" data-anchor-id="软件操作stata-psmatch2-teffects-与-r-matchit-weightit">8.6.2 软件操作：Stata (<code>psmatch2</code>, <code>teffects</code>) 与 R (<code>MatchIt</code>, <code>WeightIt</code>)</h3>
</section><section id="研究报告规范与常见误区" class="level3"><h3 class="anchored" data-anchor-id="研究报告规范与常见误区">8.6.3 研究报告规范与常见误区</h3>
</section></section><section id="本章总结" class="level2"><h2 class="anchored" data-anchor-id="本章总结">本章总结</h2>
<p>倾向得分匹配通过模拟随机实验的逻辑，在观察性研究中为处理组个体寻找特征相似的控制组个体，从而减少可观测混杂因素的影响。本章系统介绍了从倾向得分估计、匹配方法选择、平衡性检验到因果效应估计的完整流程。</p>
<p>需要强调的是，PSM只能控制<strong>可观测</strong>的混杂变量，其有效性依赖于<strong>强可忽略性假设</strong>。对于不可观测的混杂因素，PSM无法解决，需要借助其他方法（如工具变量、固定效应模型等）或进行敏感性分析。</p>
<p>成功的PSM应用不仅依赖于恰当的统计方法，更取决于： 1. 对研究问题的深入理解 2. 对相关混杂因素的全面测量 3. 对匹配结果的严谨诊断检验 4. 对模型假设和局限性的清晰认识</p>
<p>倾向得分方法已发展出多种扩展形式，包括逆概率加权、双重稳健估计、广义倾向得分和边际结构模型，这些方法丰富了观察性研究中因果推断的工具箱。在实际应用中，研究者应根据具体研究问题和数据特征选择合适的方法，并通过敏感性分析评估估计结果的稳健性。</p>
<p>最后，无论使用哪种基于倾向得分的方法，都必须牢记：这些方法只能解决由可观测变量导致的选择偏差。对于因果推断，没有任何统计方法可以完全替代良好的研究设计和严谨的理论思考。</p>


</section></main><!-- /main --><script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "已复制");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "已复制");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script><nav class="page-navigation"><div class="nav-page nav-page-previous">
      <a href="../chapters/7工具变量法.html" class="pagination-link" aria-label="7 工具变量法">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-title">7 工具变量法</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../chapters/9双重差分法.html" class="pagination-link" aria-label="9 双重差分法">
        <span class="nav-page-text"><span class="chapter-title">9 双重差分法</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->



</body></html>